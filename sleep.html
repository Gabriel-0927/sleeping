<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>夢境遊戲 - 百日夢</title>
    
    <style>
        :root { --dark-bg: #1a1a2e; --container-bg: #16213e; --border-color: #0f3460; --primary-text: #e0e0e0; --highlight-color: #e94560; --good-color: #3f72af; --bad-color: #d9534f; --neutral-color: #f0ad4e; }
        body { font-family: 'Microsoft JhengHei', 'Arial', sans-serif; background-color: var(--dark-bg); color: var(--primary-text); display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; }
        .hidden { display: none !important; }
        #game-container, #nexus-container { position: relative; width: 90%; max-width: 700px; background-color: var(--container-bg); padding: 25px; border-radius: 15px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.1); border: 1px solid var(--border-color); transition: filter 0.3s, transform 0.3s; z-index: 10; }
        #game-container.frozen { filter: blur(5px); transform: scale(0.98); pointer-events: none; }
        h1, h2 { text-align: center; color: var(--highlight-color); text-shadow: 0 0 5px var(--highlight-color); }
        #player-stats { display: flex; justify-content: space-around; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; font-size: 1.1em; flex-wrap: wrap; }
        #game-log { background-color: #0f1c2e; border: 1px solid var(--border-color); padding: 15px; height: 150px; overflow-y: scroll; margin-bottom: 20px; border-radius: 5px; scroll-behavior: smooth; }
        button, .card { -webkit-tap-highlight-color: transparent; }
        button { padding: 12px 25px; font-size: 18px; font-weight: bold; cursor: pointer; border: none; border-radius: 8px; background-color: var(--highlight-color); color: white; transition: background-color 0.3s, transform 0.1s; user-select: none; }
        button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.7; }
        button:not(:disabled):active { transform: translateY(1px); }
        .upgrade-item { background-color: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); padding: 15px; margin-bottom: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        .upgrade-item div { flex-basis: 70%; } .upgrade-item button { flex-basis: 25%; } .upgrade-item p { margin: 2px 0; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.3s; background-color: rgba(0, 0, 0, 0.7); }
        .modal:not(.hidden) { opacity: 1; pointer-events: all; }
        .modal-content { background-color: var(--container-bg); padding: 30px; border-radius: 15px; border: 1px solid var(--border-color); width: 90%; max-width: 500px; text-align: center; transform: scale(0.9); transition: transform 0.3s; position: relative; }
        .modal:not(.hidden) .modal-content { transform: scale(1); }
        #minigame-instruction, #event-instruction { min-height: 20px; color: var(--neutral-color); margin-top: 0; }
        #minigame-info-bar { display: flex; justify-content: space-around; font-size: 1.2em; font-weight: bold; margin-bottom: 15px; min-height: 25px; }
        #minigame-area { position: relative; width: 100%; height: 250px; background-color: #0f1c2e; border-radius: 10px; margin: 15px 0; overflow: hidden; user-select: none; -webkit-tap-highlight-color: transparent; }
        #minigame-result { font-size: 1.5em; margin-top: 20px; font-weight: bold; min-height: 50px; transition: color 0.3s; }
        #potion-effect-status { text-align: center; color: var(--neutral-color); min-height: 20px; margin-bottom: 15px; font-weight: bold; }
        #settings-area { position: absolute; top: 15px; right: 15px; }
        #settings-button { font-size: 1.2em; padding: 5px 10px; background: none; border: 1px solid var(--border-color); }
        #story-modal-text { font-size: 1.2em; line-height: 1.6; margin-bottom: 25px; }
        #ending-modal .modal-content, #ending-modal-2 .modal-content { background: linear-gradient(180deg, #1a1a2e, #0f1c2e); border-color: #e94560; }
        #ending-title, #ending-title-2 { font-size: 2.5em; color: var(--highlight-color); }
        #ending-text, #ending-text-2 { font-size: 1.2em; margin: 20px 0; }
        #ending-buttons, #ending-buttons-2 { display: flex; justify-content: center; gap: 20px; margin-top: 25px; }
        #ending-continue-button, #ending-continue-button-2 { background-color: var(--good-color); }
        #backpack-items .upgrade-item div { flex-basis: 60%; }
        #backpack-items .upgrade-item button { flex-basis: 35%; }
        #mobile-controls-container { display: none; margin-top: 15px; }
        #mobile-controls-container.visible { display: flex; justify-content: space-around; align-items: center; }
        .mobile-btn { flex-grow: 1; margin: 0 5px; padding: 15px 10px; font-size: 2em; background-color: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.4); }
        #mobile-hold-button { width: 80%; padding: 20px; font-size: 1.5em; background-color: var(--good-color); }
        #nexus-container { padding: 10px; text-align: center; }
        #nexusCanvas { max-width: 100%; height: auto; background-color: #0f1c2e; border: 2px solid var(--border-color); border-radius: 15px; cursor: pointer; -webkit-tap-highlight-color: transparent; }
        #nexus-container h1 { color: var(--highlight-color); text-shadow: 0 0 5px var(--highlight-color); margin-bottom: 10px; }
        #nexus-container p { color: var(--neutral-color); margin-top: 0; }
        .card-back { background: radial-gradient(ellipse at center, #4c4c4c 0%,#1a1a2e 100%); font-size: 3em; color: var(--neutral-color); text-shadow: 0 0 10px var(--neutral-color); animation: pulse-glow 3s ease-in-out infinite; }
        .card-front { background: radial-gradient(ellipse at center, #16213e 0%, #0f1c2e 100%); transform: rotateY(180deg); }
        .fortune-name { text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff, 0 0 8px currentColor; }
        .fortune-tagline { color: var(--primary-text); text-shadow: 1px 1px 2px #000; }
        @keyframes pulse-glow { 0% { text-shadow: 0 0 10px var(--neutral-color); } 50% { text-shadow: 0 0 25px var(--neutral-color); } 100% { text-shadow: 0 0 10px var(--neutral-color); } }
        .meteor { position: fixed; font-size: 2em; color: yellow; text-shadow: 0 0 10px orange; user-select: none; pointer-events: auto; cursor: pointer; z-index: 1002; } @keyframes fall-meteor { 0% { transform: translate(0, 0) rotate(-45deg); opacity: 1; } 100% { transform: translate(-100vw, 100vh) rotate(-45deg); opacity: 0; } } #card-container { display: flex; justify-content: space-around; perspective: 1000px; margin-top: 20px; } .card { width: 100px; height: 150px; cursor: pointer; } .card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; } .card.is-flipped .card-inner { transform: rotateY(180deg); } .card-face { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; border-radius: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 10px; box-sizing: border-box; } .star { position: absolute; font-size: 3em; cursor: pointer; user-select: none; } .emotion-icon { position: absolute; font-size: 3.5em; cursor: pointer; user-select: none; animation: fall linear forwards; } .star.popped, .emotion-icon.popped, .fish.popped, .meteor.popped { animation: pop 0.3s ease-out forwards; } @keyframes pop { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(2.5); opacity: 0; } } @keyframes fall { 0% { top: -50px; } 100% { top: 250px; } }
        #qte-timer-bar-container { width: 100%; height: 10px; background-color: #555; border-radius: 5px; margin-top: 10px; } #qte-timer-bar { width: 100%; height: 100%; background-color: var(--neutral-color); border-radius: 5px; transition: width 2s linear; } .screen-flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1001; pointer-events: none; animation: flash-anim 0.4s ease-out; } @keyframes flash-anim { from { opacity: 0.7; } to { opacity: 0; } } #player-avatar, .shadow-obstacle { position: absolute; } #player-avatar { bottom: 10px; width: 30px; height: 30px; background-color: var(--good-color); border-radius: 50%; box-shadow: 0 0 10px white; } #player-avatar.hit { animation: player-hit 0.5s; } @keyframes player-hit { 50% { background-color: var(--bad-color); transform: scale(1.2); } } .shadow-obstacle { width: 40px; height: 40px; background-color: #444; border-radius: 10px; animation: fall linear forwards; } .fishing-line { position: absolute; width: 2px; height: 0; background-color: white; top: 0; left: 50%; transition: height 0.3s ease-out; } .fish { position: absolute; font-size: 2em; } .memory-star { position: absolute; font-size: 2.5em; cursor: pointer; transition: transform 0.2s, text-shadow 0.2s; } .memory-star.highlight { text-shadow: 0 0 15px yellow; transform: scale(1.3); } .memory-star.wrong { animation: flash-red 0.5s; } .memory-star.correct-path { animation: flash-green 0.5s; } @keyframes flash-red { 50% { text-shadow: 0 0 15px red; } } @keyframes flash-green { 50% { text-shadow: 0 0 15px lightgreen; } } .dream-fragment { position: absolute; width: 40px; height: 40px; background-color: rgba(255, 255, 255, 0.1); border: 2px solid var(--neutral-color); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.5em; cursor: pointer; transition: background-color 0.2s; } .dream-fragment.clicked { background-color: var(--good-color); border-color: lightgreen; } #paralysis-bar-container { width: 80%; height: 40px; background-color: #0f1c2e; border: 2px solid #555; border-radius: 10px; margin: 50px auto; } #paralysis-bar { width: 0%; height: 100%; background-color: var(--good-color); border-radius: 8px; transition: width 0.1s linear; } #paralysis-pulse { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(217, 83, 79, 0.7); opacity: 0; animation: pulse-anim 1.5s ease-in-out infinite; } @keyframes pulse-anim { 5% { opacity: 1; } 25% { opacity: 0; } }
        .volume-control { margin: 20px 0; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .volume-control label { font-size: 1.1em; }
        .volume-control input[type="range"] { flex-grow: 1; max-width: 250px; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="settings-area">
            <button id="settings-button">⚙️</button>
        </div>
        <h1>夢境遊戲</h1>
        <div id="player-stats">
            <p>天數: <span id="day-count">0</span> ☀️</p>
            <p>金錢: <span id="money">0</span> 💰</p>
            <p>好夢機率: <span id="good-dream-chance">50</span>% ✨</p>
        </div>
        <div id="potion-effect-status"></div>
        <div id="game-log"></div>
        <div id="controls" style="text-align:center; margin-bottom:25px; display: flex; justify-content: center; gap: 20px;">
            <button id="sleep-button">入睡</button>
            <button id="backpack-button" style="background-color: var(--good-color);">背包</button>
            <button id="nexus-portal-button" style="background-color: var(--neutral-color);">窺探夢樞</button>
        </div>
        <div id="upgrades">
            <h2>升級商店</h2>
            <div class="upgrade-item">
                <div>
                    <p><strong>升級床</strong> (等級: <span id="bed-level">1</span>)</p>
                    <p>效果: +5% 基礎好夢機率 (上限95%)</p>
                    <p>價格: <span id="bed-upgrade-cost">50</span> 💰</p>
                </div>
                <button id="upgrade-bed-button">升級</button>
            </div>
             <div class="upgrade-item">
                <div>
                    <p><strong>升級枕頭</strong> (等級: <span id="pillow-level">1</span>)</p>
                    <p>效果: 提高金錢獲取量</p>
                    <p>價格: <span id="pillow-upgrade-cost">70</span> 💰</p>
                </div>
                <button id="upgrade-pillow-button">升級</button>
            </div>
            <div class="upgrade-item">
                <div>
                    <p><strong>購買捕夢網</strong> (等級: <span id="dreamcatcher-level">1</span>)</p>
                    <p>效果: 減少壞夢的金錢損失 (每級-10%)</p>
                    <p>價格: <span id="dreamcatcher-upgrade-cost">100</span> 💰</p>
                </div>
                <button id="upgrade-dreamcatcher-button">升級</button>
            </div>
            <div class="upgrade-item">
                <div>
                    <p><strong>購買寧神薰香</strong> (等級: <span id="incense-level">1</span>)</p>
                    <p>效果: 延長好夢時間 / 降低壞夢難度</p>
                    <p>價格: <span id="incense-upgrade-cost">120</span> 💰</p>
                </div>
                <button id="upgrade-incense-button">升級</button>
            </div>
        </div>
        <div id="item-shop">
            <h2>物品商店</h2>
            <div class="upgrade-item">
                <div>
                    <p><strong>幸運四葉草</strong> (效果: 下次必定好夢)</p>
                    <p>價格: <span id="good-dream-item-cost">150</span> 💰</p>
                </div>
                <button id="buy-good-dream-item-button">購買</button>
            </div>
            <div class="upgrade-item">
                <div>
                    <p><strong>詛咒娃娃</strong> (效果: 下次必定壞夢)</p>
                    <p>價格: <span id="bad-dream-item-cost">50</span> 💰</p>
                </div>
                <button id="buy-bad-dream-item-button">購買</button>
            </div>
        </div>
    </div>

    <div id="nexus-container" class="hidden">
        <h1>清醒夢樞</h1>
        <p>點擊或將手指移動到場景中的物體上來與它們互動</p>
        <canvas id="nexusCanvas" width="800" height="600"></canvas>
    </div>
    
    <div id="minigame-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="minigame-title"></h3>
            <p id="minigame-instruction"></p>
            <div id="minigame-info-bar"></div>
            <div id="minigame-area"></div>
            <div id="minigame-result"></div>
            <div id="mobile-controls-container"></div>
        </div>
    </div>

    <div id="event-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="event-title">夢境的啟示</h3>
            <p id="event-instruction">似乎有什麼事要發生了... 請選擇一張卡牌，看看你的運勢。</p>
            <div id="card-container"></div>
            <p id="event-result" style="font-size: 1.2em; min-height: 40px; margin-top: 20px;"></p>
        </div>
    </div>

    <div id="merchant-modal" class="modal hidden">
        <div class="modal-content">
            <h3>神秘的夢境商人出現了！</h3>
            <p>他將在 <span id="merchant-timer"></span> 秒後離去...</p>
            <div id="merchant-items"></div>
        </div>
    </div>

    <div id="story-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="story-modal-title"></h3>
            <p id="story-modal-text"></p>
            <button id="story-modal-close-button">繼續</button>
        </div>
    </div>

    <div id="ending-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="ending-title">第一篇章・完</h2>
            <p id="ending-text">感謝您的遊玩！新的篇章已經為您揭曉...</p>
            <div id="ending-buttons">
                <button id="ending-continue-button">繼續遊玩</button>
                <button id="ending-reset-button">重新開始</button>
            </div>
        </div>
    </div>
    
    <div id="ending-modal-2" class="modal hidden">
        <div class="modal-content">
            <h2 id="ending-title-2">第二篇章・覺醒</h2>
            <p id="ending-text-2">你已掌握清醒夢的核心，所有的記憶碎片都合而為一。這片夢境不再是你的牢籠，而是你的畫布。未來，將由你親手描繪...</p>
            <div id="ending-buttons-2">
                <button id="ending-continue-button-2">繼續探索</button>
                <button id="ending-reset-button-2">重溫舊夢</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal hidden">
        <div class="modal-content">
            <h2>設定</h2>
            <div class="volume-control">
                <label for="volume-slider">🎵 音量</label>
                <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
            </div>
            <p>您確定要刪除所有進度，回到第一天嗎？此動作無法復原。</p>
            <button id="delete-save-button" style="background-color: var(--bad-color);">刪除存檔並重置</button>
            <button id="settings-close-button" style="background-color: #555; margin-top: 10px;">取消</button>
        </div>
    </div>

    <div id="backpack-modal" class="modal hidden">
        <div class="modal-content">
            <h2>背包</h2>
            <div id="backpack-items" style="max-height: 400px; overflow-y: auto; padding: 10px;"></div>
            <button id="backpack-close-button" style="background-color: #555; margin-top: 20px;">關閉</button>
        </div>
    </div>

    <div id="alert-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="alert-title">提示</h3>
            <p id="alert-text"></p>
            <button id="alert-close-button">確認</button>
        </div>
    </div>
    
    <audio id="bgm" loop src="https://incompetech.com/music/royalty-free/mp3-royaltyfree/Lightless%20Dawn.mp3"></audio>

    <script>
    // --- 1. 遊戲狀態與設定 ---
    let dayCount, money, baseGoodDreamChance, pillowLevel, dreamCatcherLevel, incenseLevel, bedLevel, musicVolume;
    let bedUpgradeCost, pillowUpgradeCost, dreamCatcherUpgradeCost, incenseUpgradeCost;
    let inventory, gameLogHTML, tempGoodDreamChanceBonus;
    let effectNextGoodDream = false, effectNextBadDream = false, activePotion = null; 
    let currentView = 'dream_room';

    const goodDreamItemCost = 150, badDreamItemCost = 50;
    const isTouchDevice = 'ontouchstart' in window;
    let mainScreenEventActive = false, minigameActive = false, eventActive = false, storyModalActive = false, endingActive = false, settingsModalActive = false, backpackModalActive = false, alertModalActive = false;
    let gameInterval, gameTimeout, keydownHandler, keyupHandler, mousemoveHandler, touchMoveHandler, touchStartHandler, touchEndHandler, mainEventInterval;

    const itemsData = { 'luckyClover': { name: '幸運四葉草', description: '使用後，下次入睡必定是好夢。' }, 'cursedDoll': { name: '詛咒娃娃', description: '使用後，下次入睡必定是壞夢。' }, 'power': { name: '力量藥水', description: '下次夢境金錢獲取量加倍，但好夢機率減半。', effect: { moneyMultiplier: 2, goodChanceMultiplier: 0.5 } }, 'peace': { name: '安神藥水', description: '下次夢境必定成功，但金錢獲取量減半。', effect: { moneyMultiplier: 0.5, forceSuccess: true } }, 'greed': { name: '貪婪藥水', description: '下次夢境金錢獲取量變為三倍，但必定是壞夢。', effect: { moneyMultiplier: 3, forceBadDream: true } }, 'risk': { name: '風險藥劑', description: '下次夢境若是好夢，獎勵x3；若是壞夢，懲罰也x3。', effect: { moneyMultiplier: 3, isRisky: true } } };
    const goodDreams = [ { name: '星光捕手', startFunction: startStarCatcher }, { name: '記憶星軌', startFunction: startMemoryTrail }, { name: '夢境釣魚', startFunction: startDreamFishing }, { name: '情緒整理', startFunction: startTidyEmotions }, { name: '夢境編織', startFunction: startDreamWeaving } ];
    const badDreams = [ { name: '夢魘掙脫', startFunction: startNightmareEscape }, { name: '迷宮岔路', startFunction: startMazeQTE }, { name: '躲避陰影', startFunction: startDodgeShadows }, { name: '鬼壓床', startFunction: startSleepParalysis } ];
    const fortunes = [ { name: '大吉', color: '#ff4757', tagline: '今天將是無與倫比的一天！', effect: () => { const bonus = 50 + 10 * pillowLevel; money += bonus; return `獲得了 ${bonus} 💰 的意外之財！`; } }, { name: '中吉', color: '#ffa502', tagline: '好運正在向你招手。', effect: () => { tempGoodDreamChanceBonus = 10; return `下次入睡的好夢機率暫時提升10%！`; } }, { name: '小吉', color: '#2ed573', tagline: '微小的幸運，也能帶來快樂。', effect: () => { const bonus = 20 + 5 * pillowLevel; money += bonus; return `撿到了 ${bonus} 💰！`; } }, { name: '凶', color: '#5352ed', tagline: '烏雲籠罩...看來要小心行事。', effect: () => { const loss = 15 * bedLevel; money = Math.max(0, money - loss); return `不小心遺失了 ${loss} 💰...`; } }, { name: '大凶', color: '#1e272e', tagline: '諸事不順，破財之相！', effect: () => { money = Math.floor(money * 0.8); return `遭遇迎頭痛擊，損失了20%的財產！`; } } ];
    const randomMainEvents = [ { name: 'Meteor Shower', start: startMeteorShower }, { name: 'Dream Merchant', start: startDreamMerchant } ];
    const merchantPotions = [ { id: 'power', cost: 100 }, { id: 'peace', cost: 120 }, { id: 'greed', cost: 200 }, { id: 'risk', cost: 80 } ];
    const storyData = { 1: { title: "第一夜", text: "這是一個奇怪的夢...感覺既熟悉又陌生。" }, 5: { title: "第五夜", text: "偶爾，你會在壞夢的邊緣瞥見一些陰影，它們似乎在低語。" }, 10: { title: "第十夜的記憶", text: "你感覺床鋪柔軟得不可思議。夢中的金錢似乎也變得更『真實』了。一絲模糊的記憶閃過：一間明亮的房間，窗外是綠色的...是什麼？" }, 15: { title: "第十五夜", text: "你開始習慣在夢中醒來，升級，然後再次入睡。這彷彿成了一種儀式。" }, 20: { title: "第二十夜的低語", text: "你在壞夢中聽見了更清晰的耳語：『...還不夠...』。是誰在說話？" }, 25: { title: "第二十五夜", text: "夢境商人是個奇怪的傢伙。他的藥水效果強大，但總感覺他對你的處境瞭若指掌。" }, 30: { title: "第三十夜的氣味", text: "夢境的色彩比平時更鮮豔了。你第一次在夢裡，聞到了寧神薰香的味道...這味道讓你幾乎想起了某個溫暖的午後。" }, 38: { title: "第三十八夜", text: "有那麼一瞬間，你看著枕頭，覺得它應該是另一種顏色。但你很快就忘了那是什麼顏色。" }, 40: { title: "第四十夜的瞥見", text: "你瞥見一個神秘的影子，它似乎就是那位偶爾出現的商人。他對你點了點頭，便消失在迷霧中。他不是敵人嗎？" }, 46: { title: "第四十六夜", text: "流星雨劃過天際時，你許了一個願：『我想回家』。但你甚至不確定家在哪裡。" }, 50: { title: "第五十夜的碎片", text: "半夢半醒之間，你抓住了一些記憶碎片：笑聲、陽光、還有一個模糊的人影。但它們像指間的沙一樣溜走。心裡一陣刺痛。" }, 58: { title: "第五十八夜", text: "捕夢網不僅能擋住金錢的流失，似乎也能過濾掉一些最深沉的恐懼。" }, 60: { title: "第六十夜的淚珠", text: "你發現捕夢網上掛著一顆小小的、閃光的露珠。你觸碰它，一股悲傷的情緒湧上心頭。這不是你的...對吧？" }, 67: { title: "第六十七夜", text: "你開始享受情緒整理的過程，將混亂的感覺一一歸位，似乎也在整理自己混亂的記憶。" }, 70: { title: "第七十夜的遼闊", text: "夢中的世界變得廣闊無邊，你感覺自己彷彿能走到任何地方...只要你還想繼續做夢。但...你真的想嗎？" }, 75: { title: "第七十五夜", text: "你開始懷疑，這些好夢和壞夢，也許都源於你自己。" }, 80: { title: "第八十夜的光芒", text: "你對夢境的掌控力越來越強。在一次壞夢中，你憑藉自己的意志點亮了一盞燈，陰影短暫地退去了。你第一次感覺到力量。" }, 88: { title: "第八十八夜", text: "『醒來』這個詞，現在聽起來既充滿希望，又讓人畏懼。" }, 90: { title: "第九十夜的平靜", text: "一種奇特的平靜感籠罩著你。你不再害怕壞夢，也不再貪戀好夢。你好像...準備好了。" }, 95: { title: "第九十五夜", text: "你最後一次升級了你的床。它無比舒適，但你知道你不會再需要它了。" }, 99: { title: "第九十九夜", text: "最後一夜。你平靜地躺下，你知道，這次入睡將會是最後一次。" },
      101: { title: "第一百零一夜的甦醒", text: "你不再是『窺探』，而是真正踏入了這個被稱為『清醒夢樞』的地方... 這裡的一切都散發著奇異的能量，既熟悉又陌生。" },
      110: { title: "破碎的倒影", text: "你走近那面破碎的『記憶之鏡』，鏡中映出的不是你的臉，而是一些飛逝的、無法捕捉的畫面... 你感覺到，最重要的東西就在裡面，被裂痕分割得支離破碎。" },
      120: { title: "奇想花園的種子", text: "在一次特別甜美的好夢後，你發現手中多了一顆發光的種子。你將它種在『奇想花園』的土壤裡，它似乎…在回應你的期待。" },
      125: { title: "核心的守衛", text: "當你試圖觸碰鏡子深處時，一個巨大的陰影從夢樞的深淵中浮現，它發出警告般的低吼。你明白了，有些記憶...是被『保護』著的。" },
      135: { title: "煉金工坊的低語", text: "『煉金工坊』的燒瓶在你靠近時發出微光。你隱約感覺到，那些在夢中收集到的情緒、恐懼與喜悅，都能在這裡轉化為更實質的力量。" },
      142: { title: "浮現的技能樹", text: "一股強烈的意志流過你的腦海，『清醒技能樹』上的一個節點被點亮了。你感覺自己對夢境的掌控力，又提升了一個層次。" },
      150: { title: "第一次挑戰", text: "你鼓起勇氣，第一次向陰影守衛發起了挑戰。儘管慘敗而歸，但你從中感受到了一種名為『清明殘響』的特殊能量。你知道了自己該做什麼。" },
      158: { title: "商人的真面目", text: "夢境商人再次出現，但這次他沒有推銷藥水，只是靜靜地看著你。你突然意識到，他就是那個曾在第四十夜瞥見的、友善的影子。他似乎在引導你。" },
      165: { title: "花園的饋贈", text: "花園中的種子終於開花結果，你收穫了一瓶效果遠超商人藥水的『濃縮夢境精華』。這是你親手栽培出的力量。" },
      170: { title: "鏡中的人影", text: "隨著你擊敗了幾個較弱的守衛，鏡子的裂痕修復了一些。在一次凝視中，你清楚地看到了那個模糊人影的側臉...一種難以言喻的悲傷湧上心頭。" },
      180: { title: "陰影的本質", text: "你逐漸明白，那些守衛並非敵人，而是你內心深處的恐懼、懷疑與不安的化身。擊敗它們，更像是與自己和解的過程。" },
      188: { title: "技能樹的頂端", text: "當你點亮技能樹的一個分支頂點時，你感覺自己幾乎能隨心所欲地改變夢境的樣貌。壞夢的威脅對你來說，已如清風拂面。" },
      195: { title: "記憶即將完整", text: "鏡子只剩下最後一道裂痕，而最強大的守衛——那個代表著你最深恐懼的化身，正在裂痕的另一端等待著你。" },
      199: { title: "最後的準備", text: "最後一夜。你回望身後的夢境房間與升級過的床鋪，它們陪你走過了漫長的旅途。現在，是時候面對一切了。" }
     };
    
    // --- 2. 元素變數宣告 ---
    let gameContainer, nexusContainer, dayCountEl, moneyEl, goodDreamChanceEl, gameLogEl, sleepButton, bedLevelEl, pillowLevelEl, dreamCatcherLevelEl, incenseLevelEl, bedUpgradeCostEl, pillowUpgradeCostEl, dreamCatcherUpgradeCostEl, incenseUpgradeCostEl, upgradeBedButton, upgradePillowButton, upgradeDreamCatcherButton, upgradeIncenseButton, minigameModal, minigameTitle, minigameInstruction, minigameInfoBar, minigameArea, minigameResultEl, eventModal, eventResultEl, cardContainer, goodDreamItemCostEl, badDreamItemCostEl, buyGoodDreamItemButton, buyBadDreamItemButton, merchantModal, merchantTimerEl, merchantItemsEl, potionEffectStatusEl, settingsButton, settingsModal, deleteSaveButton, settingsCloseButton, storyModal, storyModalTitle, storyModalText, storyModalCloseButton, endingModal, endingText, endingResetButton, endingContinueButton, backpackButton, backpackModal, backpackItemsEl, backpackCloseButton, mobileControlsContainer, nexusPortalButton, alertModal, alertText, alertCloseButton, endingModal2, endingResetButton2, endingContinueButton2, bgmEl, volumeSliderEl;

    // --- 3. 核心功能函式 ---
    function logMessage(message, isLoad = false) { const p = document.createElement('p'); p.innerHTML = message; gameLogEl.appendChild(p); gameLogEl.scrollTop = gameLogEl.scrollHeight; if (!isLoad) { gameLogHTML = gameLogEl.innerHTML; saveGame(); } }
    
    function updateStatsUI() { 
        if(!dayCountEl) return;
        dayCountEl.textContent = dayCount;
        moneyEl.textContent = money; 
        goodDreamChanceEl.innerHTML = `${baseGoodDreamChance}% ${tempGoodDreamChanceBonus > 0 ? `<span style="color:var(--good-color)">(+${tempGoodDreamChanceBonus}%)</span>` : ''}`;

        bedLevelEl.textContent = bedLevel; pillowLevelEl.textContent = pillowLevel; dreamCatcherLevelEl.textContent = dreamCatcherLevel; incenseLevelEl.textContent = incenseLevel;
        bedUpgradeCostEl.textContent = bedUpgradeCost; pillowUpgradeCostEl.textContent = pillowUpgradeCost; dreamCatcherUpgradeCostEl.textContent = dreamCatcherUpgradeCost; incenseUpgradeCostEl.textContent = incenseUpgradeCost;
        
        const buttonsDisabled = minigameActive || eventActive || mainScreenEventActive || storyModalActive || endingActive || settingsModalActive || backpackModalActive || alertModalActive;
        
        sleepButton.disabled = buttonsDisabled; 
        backpackButton.disabled = buttonsDisabled;
        nexusPortalButton.disabled = buttonsDisabled;
        if (dayCount >= 100) { nexusPortalButton.textContent = "前往夢樞"; } else { nexusPortalButton.textContent = "窺探夢樞"; }
        upgradeBedButton.disabled = money < bedUpgradeCost || buttonsDisabled || baseGoodDreamChance >= 95;
        upgradePillowButton.disabled = money < pillowUpgradeCost || buttonsDisabled;
        upgradeDreamCatcherButton.disabled = money < dreamCatcherUpgradeCost || buttonsDisabled;
        upgradeIncenseButton.disabled = money < incenseUpgradeCost || buttonsDisabled;
        buyGoodDreamItemButton.disabled = money < goodDreamItemCost || buttonsDisabled;
        buyBadDreamItemButton.disabled = money < badDreamItemCost || buttonsDisabled;
        
        let effectText = "";
        if (effectNextGoodDream) effectText = "效果: 下次必定好夢";
        else if (effectNextBadDream) effectText = "效果: 下次必定壞夢";
        else if (activePotion) effectText = `藥水效果: ${itemsData[activePotion.id].name}`;
        potionEffectStatusEl.textContent = effectText;
    }
    
    function goToSleep() {
        if (dayCount === 0 && storyData[1]) { logMessage(`<i>${storyData[1].text}</i>`); }
        dayCount++;
        logMessage(`--- 第 ${dayCount} 天 ---`);
        
        let isGoodDream;
        if (effectNextGoodDream) { isGoodDream = true; effectNextGoodDream = false; logMessage("🍀 你使用了幸運四葉草..."); } 
        else if (effectNextBadDream) { isGoodDream = false; effectNextBadDream = false; logMessage("🎎 你使用了詛咒娃娃..."); } 
        else if (activePotion && itemsData[activePotion.id].effect.forceBadDream) { isGoodDream = false; logMessage(`🧪 ${itemsData[activePotion.id].name} 的效果發作了...`); } 
        else { 
            let finalChance = baseGoodDreamChance + tempGoodDreamChanceBonus;
            finalChance *= (activePotion ? (itemsData[activePotion.id].effect.goodChanceMultiplier || 1) : 1);
            isGoodDream = Math.random() * 100 < finalChance; 
        }
        tempGoodDreamChanceBonus = 0;
        
        minigameActive = true; 
        saveGameAndUpdateUI();
        logMessage("你緩緩閉上眼睛，進入了夢鄉..."); 

        setTimeout(() => { 
            const dreamPool = isGoodDream ? goodDreams : badDreams; 
            const selectedDream = dreamPool[Math.floor(Math.random() * dreamPool.length)]; 
            selectedDream.startFunction(); 
        }, 1500); 
    }

    function checkPostSleepEvents() {
        hideMinigame();
        if (dayCount >= 200 && !saveGame.seenEnding2) {
            setTimeout(showEnding2, 500);
        } else if (dayCount >= 100 && !saveGame.seenEnding) {
            setTimeout(showEnding, 500);
        } else if (storyData[dayCount]) {
            setTimeout(() => showStory(dayCount), 500);
        }
    }
    
    function showEndScreen(resultText, logText, success) { 
        if (!minigameActive) return;
        if (activePotion && itemsData[activePotion.id].effect.forceSuccess) { success = true; resultText += " (藥水效果)"; }
        
        minigameActive = false; 
        clearTimersAndListeners(); 
        minigameArea.style.pointerEvents = 'none'; 
        minigameResultEl.textContent = resultText; 
        minigameResultEl.style.color = success === false ? 'var(--bad-color)' : success === true ? 'var(--good-color)' : 'var(--neutral-color)'; 
        if (logText) logMessage(logText); 
        
        if(activePotion) { logMessage(`🧪 ${itemsData[activePotion.id].name} 的效果消失了。`); activePotion = null; }
        
        saveGame();
        
        const EVENT_CHANCE = 0.3; 
        if (Math.random() < EVENT_CHANCE && dayCount < 100) { setTimeout(() => startFortuneEvent(), 2000); } 
        else { setTimeout(checkPostSleepEvents, 3000); } 
    }
    
    function hideMinigame() { 
        gameContainer.classList.remove('frozen'); 
        minigameModal.classList.add('hidden'); 
        if (!eventActive && !storyModalActive && !endingActive) { minigameActive = false; saveGameAndUpdateUI(); } 
    }
    
    function flipCard(clickedCard, chosenFortune) { 
        document.querySelectorAll('.card').forEach(c => c.onclick = null); clickedCard.classList.add('is-flipped'); const effectMessage = chosenFortune.effect(); logMessage(`【運勢：${chosenFortune.name}】${chosenFortune.tagline} ${effectMessage}`); eventResultEl.textContent = effectMessage; saveGameAndUpdateUI();
        setTimeout(() => { document.querySelectorAll('.card:not(.is-flipped)').forEach(otherCard => { otherCard.classList.add('is-flipped'); }); }, 1000); 
        setTimeout(() => { eventModal.classList.add('hidden'); eventActive = false; checkPostSleepEvents(); }, 4000); 
    }

    function calculateEarnings(baseAmount, isLoss = false) {
        let multiplier = 1;
        if (activePotion) {
            if (itemsData[activePotion.id].effect.isRisky) { multiplier = 3; } 
            else if (!isLoss) { multiplier = itemsData[activePotion.id].effect.moneyMultiplier || 1; }
        }
        let finalAmount = baseAmount * multiplier;
        if (isLoss) { const lossReduction = 1 - (dreamCatcherLevel - 1) * 0.1; finalAmount *= lossReduction; }
        return Math.round(finalAmount);
    }
    
    function upgradeBed() { if (money >= bedUpgradeCost) { money -= bedUpgradeCost; bedLevel++; baseGoodDreamChance = Math.min(95, baseGoodDreamChance + 5); bedUpgradeCost = Math.floor(bedUpgradeCost * 1.6); logMessage(`🛠️ 床升級了！等級 ${bedLevel}，基礎好夢機率提升至 ${baseGoodDreamChance}%。`); saveGameAndUpdateUI(); } }
    function upgradePillow() { if (money >= pillowUpgradeCost) { money -= pillowUpgradeCost; pillowLevel++; pillowUpgradeCost = Math.floor(pillowUpgradeCost * 1.7); logMessage(`🛠️ 枕頭升級了！等級 ${pillowLevel}，金錢獲取量提升。`); saveGameAndUpdateUI(); } }
    function upgradeDreamCatcher() { if (money >= dreamCatcherUpgradeCost) { money -= dreamCatcherUpgradeCost; dreamCatcherLevel++; dreamCatcherUpgradeCost = Math.floor(dreamCatcherUpgradeCost * 1.8); logMessage(`🛠️ 捕夢網升級了！等級 ${dreamCatcherLevel}，能抵禦更多壞夢損失。`); saveGameAndUpdateUI(); } }
    function upgradeIncense() { if (money >= incenseUpgradeCost) { money -= incenseUpgradeCost; incenseLevel++; incenseUpgradeCost = Math.floor(incenseUpgradeCost * 1.75); logMessage(`🛠️ 寧神薰香升級了！等級 ${incenseLevel}，夢境變得更安穩。`); saveGameAndUpdateUI(); } }
    function startFortuneEvent() { eventActive = true; updateStatsUI(); eventModal.classList.remove('hidden'); cardContainer.innerHTML = ''; eventResultEl.textContent = ''; const shuffledFortunes = [...fortunes].sort(() => 0.5 - Math.random()); const selectedFortunes = shuffledFortunes.slice(0, 3); selectedFortunes.forEach(fortune => { const card = document.createElement('div'); card.className = 'card'; const cardInner = document.createElement('div'); cardInner.className = 'card-inner'; const cardBack = document.createElement('div'); cardBack.className = 'card-face card-back'; cardBack.textContent = '❓'; const cardFront = document.createElement('div'); cardFront.className = 'card-face card-front'; cardFront.innerHTML = `<div class="fortune-name" style="color:${fortune.color};">${fortune.name}</div><div class="fortune-tagline">${fortune.tagline}</div>`; cardInner.appendChild(cardBack); cardInner.appendChild(cardFront); card.appendChild(cardInner); card.onclick = () => flipCard(card, fortune); cardContainer.appendChild(card); }); }
    
    // --- 4. 存檔/商店/背包/劇情/場景系統 ---
    function saveGame() {
        const gameState = { dayCount, money, baseGoodDreamChance, bedLevel, pillowLevel, dreamCatcherLevel, incenseLevel, bedUpgradeCost, pillowUpgradeCost, dreamCatcherUpgradeCost, incenseUpgradeCost, inventory, gameLogHTML, effectNextGoodDream, effectNextBadDream, activePotion, currentView, seenEnding: saveGame.seenEnding, seenEnding2: saveGame.seenEnding2, musicVolume };
        localStorage.setItem('dreamGameSaveData', JSON.stringify(gameState));
    }

    function loadGame() {
        const savedData = localStorage.getItem('dreamGameSaveData');
        if (savedData) {
            const gameState = JSON.parse(savedData);
            dayCount = gameState.dayCount || 0; money = gameState.money || 0; baseGoodDreamChance = gameState.baseGoodDreamChance || 50; bedLevel = gameState.bedLevel || 1; pillowLevel = gameState.pillowLevel || 1; dreamCatcherLevel = gameState.dreamCatcherLevel || 1; incenseLevel = gameState.incenseLevel || 1; bedUpgradeCost = gameState.bedUpgradeCost || 50; pillowUpgradeCost = gameState.pillowUpgradeCost || 70; dreamCatcherUpgradeCost = gameState.dreamCatcherUpgradeCost || 100; incenseUpgradeCost = gameState.incenseUpgradeCost || 120; inventory = gameState.inventory || {}; gameLogHTML = gameState.gameLogHTML || "歡迎來到夢境遊戲！今晚會是什麼夢呢？"; effectNextGoodDream = gameState.effectNextGoodDream || false; effectNextBadDream = gameState.effectNextBadDream || false; activePotion = gameState.activePotion || null; currentView = gameState.currentView || 'dream_room'; saveGame.seenEnding = gameState.seenEnding || false; saveGame.seenEnding2 = gameState.seenEnding2 || false;
            musicVolume = gameState.musicVolume !== undefined ? gameState.musicVolume : 0.5;
            logMessage("💾 讀取存檔成功！歡迎回來。", true);
        } else {
            dayCount = 0; money = 0; baseGoodDreamChance = 50; bedLevel = 1; pillowLevel = 1; dreamCatcherLevel = 1; incenseLevel = 1; bedUpgradeCost = 50; pillowUpgradeCost = 70; dreamCatcherUpgradeCost = 100; incenseUpgradeCost = 120; inventory = {}; gameLogHTML = ""; effectNextGoodDream = false; effectNextBadDream = false; activePotion = null; currentView = 'dream_room'; saveGame.seenEnding = false; saveGame.seenEnding2 = false; musicVolume = 0.5;
            logMessage("歡迎來到夢境遊戲！今晚會是什麼夢呢？", true);
        }
        tempGoodDreamChanceBonus = 0;
        gameLogEl.innerHTML = gameLogHTML;
        gameLogEl.scrollTop = gameLogEl.scrollHeight;

        bgmEl.volume = musicVolume;
        volumeSliderEl.value = musicVolume;
    }
    
    function saveGameAndUpdateUI() { saveGame(); updateStatsUI(); }
    function deleteSaveAndReset() { deleteSaveButton.disabled = true; if (confirm("警告：此動作將會永久刪除您所有的遊戲進度，確定要重置嗎？")) { localStorage.removeItem('dreamGameSaveData'); location.reload(); } else { deleteSaveButton.disabled = false; } }
    function showStory(day) { storyModalActive = true; gameContainer.classList.add('frozen'); const story = storyData[day]; storyModalTitle.textContent = story.title; storyModalText.textContent = story.text; storyModal.classList.remove('hidden'); logMessage(`<strong>--- ${story.title} ---</strong><br><i>${story.text}</i>`); updateStatsUI(); }
    function showEnding() { endingActive = true; gameContainer.classList.add('frozen'); endingModal.classList.remove('hidden'); logMessage(`<strong>--- 第一篇章・完 ---</strong>`); saveGame.seenEnding = true; saveGame(); updateStatsUI(); }
    function showEnding2() { endingActive = true; gameContainer.classList.add('frozen'); endingModal2.classList.remove('hidden'); logMessage(`<strong>--- 第二篇章・覺醒 ---</strong>`); saveGame.seenEnding2 = true; saveGame(); updateStatsUI(); }

    function buyItem(itemId, cost) {
        if (money >= cost) {
            money -= cost;
            inventory[itemId] = (inventory[itemId] || 0) + 1;
            logMessage(`🛍️ 你購買了 ${itemsData[itemId].name}！`);
            saveGameAndUpdateUI();
        }
    }

    function openBackpack() { backpackModalActive = true; renderBackpack(); backpackModal.classList.remove('hidden'); updateStatsUI(); }
    function closeBackpack() { backpackModalActive = false; backpackModal.classList.add('hidden'); updateStatsUI(); }
    function renderBackpack() {
        backpackItemsEl.innerHTML = '';
        if (Object.keys(inventory).every(k => !inventory[k])) { backpackItemsEl.innerHTML = '<p>你的背包空無一物。</p>'; return; }
        for(const itemId in inventory) {
            if (inventory[itemId] > 0) {
                const item = itemsData[itemId];
                const itemDiv = document.createElement('div');
                itemDiv.className = 'upgrade-item';
                itemDiv.innerHTML = `<div><p><strong>${item.name}</strong> (持有: ${inventory[itemId]})</p><p>${item.description}</p></div><button data-item-id="${itemId}">使用</button>`;
                backpackItemsEl.appendChild(itemDiv);
            }
        }
    }
    function useItem(itemId) {
        const hasActiveEffect = effectNextGoodDream || effectNextBadDream || activePotion;
        if (hasActiveEffect) { logMessage("❌ 你已經有一個生效中的物品了！"); return; }
        inventory[itemId]--;
        if (inventory[itemId] <= 0) delete inventory[itemId];
        switch(itemId) {
            case 'luckyClover': effectNextGoodDream = true; break;
            case 'cursedDoll': effectNextBadDream = true; break;
            default: const potionData = merchantPotions.find(p => p.id === itemId); if(potionData) activePotion = potionData; break;
        }
        logMessage(`你使用了 ${itemsData[itemId].name}！`);
        closeBackpack();
        saveGameAndUpdateUI();
    }

    function switchView(viewName) {
        currentView = viewName;
        if (viewName === 'nexus') {
            gameContainer.classList.add('hidden');
            nexusContainer.classList.remove('hidden');
            initNexusCanvas.start();
        } else {
            nexusContainer.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            initNexusCanvas.stop();
        }
        saveGame();
    }
    
    function showAlert(message) {
        alertModalActive = true;
        alertText.textContent = message;
        alertModal.classList.remove('hidden');
        updateStatsUI();
    }
    
    // --- 5. 事件與小遊戲邏輯 ---
    function triggerRandomEvent() { if (currentView !== 'dream_room' || minigameActive || eventActive || mainScreenEventActive || storyModalActive || endingActive || backpackModalActive || alertModalActive) return; const CHANCE = 0.25; if (Math.random() < CHANCE) { const selectedEvent = randomMainEvents[Math.floor(Math.random() * randomMainEvents.length)]; selectedEvent.start(); } }
    function startMeteorShower() { mainScreenEventActive = true; document.body.style.overflow = 'hidden'; saveGameAndUpdateUI(); logMessage("🌠 天空開始降下流星雨！快點擊它們！"); let meteorsCaught = 0; const duration = 10000; const spawner = setInterval(() => { const meteor = document.createElement('div'); meteor.textContent = '☄️'; meteor.className = 'meteor'; meteor.style.left = `${Math.random() * 100}vw`; meteor.style.top = `-50px`; meteor.style.animation = `fall-meteor ${2 + Math.random() * 2}s linear`; meteor.onclick = () => { meteorsCaught++; const reward = Math.ceil(1 + pillowLevel * 0.5); money += reward; updateStatsUI(); meteor.classList.add('popped'); meteor.onclick = null; setTimeout(() => meteor.remove(), 300); }; document.body.appendChild(meteor); setTimeout(() => { if(meteor) meteor.remove() }, 4000); }, 300); setTimeout(() => { clearInterval(spawner); mainScreenEventActive = false; document.body.style.overflow = 'auto'; logMessage(`🌠 流星雨結束了，你抓到了 ${meteorsCaught} 顆流星！`); saveGameAndUpdateUI(); }, duration); }
    function startDreamMerchant() { mainScreenEventActive = true; saveGameAndUpdateUI(); merchantModal.classList.remove('hidden'); logMessage("🎭 一位神秘的商人出現在你的夢境邊緣..."); let timeLeft = 20; merchantTimerEl.textContent = timeLeft; merchantItemsEl.innerHTML = ''; const shuffledPotions = [...merchantPotions].sort(() => 0.5 - Math.random()); const itemsForSale = shuffledPotions.slice(0, 2); itemsForSale.forEach(potion => { const item = itemsData[potion.id]; const itemDiv = document.createElement('div'); itemDiv.className = 'upgrade-item'; itemDiv.innerHTML = `<div><p><strong>${item.name}</strong></p><p>${item.description}</p><p>價格: ${potion.cost} 💰</p></div><button data-item-id="${potion.id}" data-cost="${potion.cost}">購買</button>`; merchantItemsEl.appendChild(itemDiv); }); const buttons = merchantItemsEl.querySelectorAll('button'); buttons.forEach(b => { b.disabled = money < b.dataset.cost; b.onclick = (e) => { const itemId = e.target.dataset.itemId; const cost = parseInt(e.target.dataset.cost); buyItem(itemId, cost); buttons.forEach(btn => btn.disabled = money < btn.dataset.cost); }; }); const timer = setInterval(() => { timeLeft--; merchantTimerEl.textContent = timeLeft; if (timeLeft <= 0) { closeMerchant(timer); } }, 1000); const closeMerchant = (timerToClear = timer) => { clearInterval(timerToClear); merchantModal.classList.add('hidden'); mainScreenEventActive = false; logMessage("商人神秘地消失了..."); saveGameAndUpdateUI(); } }
    function clearTimersAndListeners() {
        clearInterval(gameInterval); clearTimeout(gameTimeout);
        if (keydownHandler) document.removeEventListener('keydown', keydownHandler);
        if (keyupHandler) document.removeEventListener('keyup', keyupHandler);
        if (mousemoveHandler) minigameArea.removeEventListener('mousemove', mousemoveHandler);
        if (touchMoveHandler) minigameArea.removeEventListener('touchmove', touchMoveHandler);
        const holdButton = document.getElementById('mobile-hold-button');
        if (holdButton) {
             if (touchStartHandler) holdButton.removeEventListener('touchstart', touchStartHandler);
             if (touchEndHandler) holdButton.removeEventListener('touchend', touchEndHandler);
        }
        minigameArea.onclick = null;
        keydownHandler = keyupHandler = mousemoveHandler = touchMoveHandler = touchStartHandler = touchEndHandler = gameInterval = gameTimeout = null;
    }
    function showMinigame() { gameContainer.classList.add('frozen'); minigameModal.classList.remove('hidden'); minigameResultEl.innerHTML = ''; minigameInfoBar.innerHTML = ''; minigameArea.innerHTML = ''; minigameInstruction.textContent = ''; mobileControlsContainer.innerHTML = ''; mobileControlsContainer.classList.remove('visible'); minigameArea.style.pointerEvents = 'auto'; }
    function startStarCatcher() { let score = 0; let duration = 7 + (incenseLevel - 1); showMinigame(); minigameTitle.textContent = "✨ 星光捕手 ✨"; minigameInstruction.textContent = "在時間內盡可能點擊出現的星星！"; minigameInfoBar.innerHTML = `<span>時間: <span id="timer">${duration}</span>s</span> <span>分數: <span id="score">0</span></span>`; const timerEl = document.getElementById('timer'); const scoreEl = document.getElementById('score'); const starSpawner = setInterval(() => { if (!minigameActive) { clearInterval(starSpawner); return; } const star = document.createElement('div'); star.textContent = '⭐'; star.className = 'star'; star.style.top = `${Math.random() * 85}%`; star.style.left = `${Math.random() * 90}%`; star.onclick = () => { if(!minigameActive) return; score++; scoreEl.textContent = score; star.onclick = null; star.classList.add('popped'); setTimeout(() => star.remove(), 300); }; minigameArea.appendChild(star); }, 500); gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); clearInterval(starSpawner); endStarCatcher(score); } }, 1000); }
    function endStarCatcher(finalScore) { const earnings = calculateEarnings(finalScore * pillowLevel * 2); money += earnings; showEndScreen(`抓到了 ${finalScore} 顆星星！獲得 ${earnings} 💰！`, `🌙 好夢中抓到 ${finalScore} 顆星星，獲得 ${earnings} 💰！`, true); }
    function startNightmareEscape() { let clicks = 0; let duration = 4; showMinigame(); minigameTitle.textContent = "👻 夢魘掙脫 👻"; minigameInstruction.textContent = "快！瘋狂點擊按鈕從夢魘中掙脫！"; minigameInfoBar.innerHTML = `<span>時間: <span id="timer">${duration}</span>s</span> <span>點擊: <span id="score">0</span></span>`; const timerEl = document.getElementById('timer'); const scoreEl = document.getElementById('score'); minigameArea.innerHTML = `<button id="mash-button" style="width: 80%; height: 80px; font-size: 1.5em; background-color: var(--bad-color);">掙脫！</button>`; document.getElementById('mash-button').onclick = () => { if(!minigameActive) return; clicks++; scoreEl.textContent = clicks; }; gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); endNightmareEscape(clicks); } }, 1000); }
    function endNightmareEscape(finalClicks) { const threshold = 15 + bedLevel - (incenseLevel - 1); let success = finalClicks >= threshold; if (success) { const moneyLost = calculateEarnings(20, true); money = Math.max(0, money - moneyLost); showEndScreen(`成功掙脫了！但還是損失了 ${moneyLost} 💰。`, `👻 成功掙脫壞夢，損失 ${moneyLost} 💰。`, success); } else { const moneyLost = calculateEarnings(40, true); money = Math.max(0, money - moneyLost); showEndScreen(`被夢魘吞噬了...損失了 ${moneyLost} 💰！`, `👻 被壞夢擊敗，損失 ${moneyLost} 💰。`, success); } }
    function startMemoryTrail() { let sequence = [], playerSequence = [], level = 1; showMinigame(); minigameTitle.textContent = "✨ 記憶星軌 ✨"; minigameInstruction.textContent = "記住星星閃爍的順序並依序點擊。"; minigameInfoBar.innerHTML = `<span>長度: <span id="score">1</span></span>`; const scoreEl = document.getElementById('score'); function nextLevel() { minigameArea.style.pointerEvents = 'none'; minigameArea.innerHTML = '<p style="font-size: 1.5em;">請記住順序...</p>'; playerSequence = []; scoreEl.textContent = level; setTimeout(() => { if(!minigameActive && !eventActive) return; minigameArea.innerHTML = ''; let positions = []; const minDistance = 18; for (let i = 0; i < level; i++) { let pos; let validPosition = false; let attempts = 0; while (!validPosition && attempts < 100) { pos = { top: 10 + Math.random() * 75, left: 10 + Math.random() * 80 }; validPosition = true; for (const existingPos of positions) { const dist = Math.sqrt(Math.pow(pos.top - existingPos.top, 2) + Math.pow(pos.left - existingPos.left, 2)); if (dist < minDistance) { validPosition = false; break; } } attempts++; } positions.push(pos); } sequence = positions.map((pos, index) => { const star = document.createElement('div'); star.className = 'memory-star'; star.textContent = '✧'; star.style.top = `${pos.top}%`; star.style.left = `${pos.left}%`; star.dataset.index = index; star.onclick = () => playerClick(star); minigameArea.appendChild(star); return star; }); setTimeout(() => minigameArea.style.pointerEvents = 'auto', level * 800); sequence.forEach((star, index) => { setTimeout(() => { star.classList.add('highlight'); setTimeout(() => star.classList.remove('highlight'), 500); }, (index + 1) * 800); }); }, 1500); } function playerClick(clickedStar) { if (playerSequence.length >= sequence.length || !minigameActive) return; const clickedIndex = parseInt(clickedStar.dataset.index); if (sequence[playerSequence.length].dataset.index != clickedIndex) { clickedStar.classList.add('wrong'); endMemoryTrail(level - 1, sequence); return; } playerSequence.push(clickedIndex); clickedStar.classList.add('highlight'); if (playerSequence.length === sequence.length) { level++; setTimeout(nextLevel, 1000); } } nextLevel(); }
    function endMemoryTrail(finalLevel, correctSequence) { if (correctSequence) { correctSequence.forEach((star, index) => { setTimeout(() => star.classList.add('correct-path'), index * 100); }); } const earnings = calculateEarnings(finalLevel * finalLevel * pillowLevel * 2); money += earnings; showEndScreen(`記憶中斷！你記住了 ${finalLevel} 個節點。獲得 ${earnings} 💰！`, `你在記憶星軌中達到了長度 ${finalLevel}，獲得 ${earnings} 💰。`, finalLevel > 0); }
    function startDreamFishing() { showMinigame(); minigameTitle.textContent = "🎣 夢境釣魚 🎣"; minigameInstruction.textContent = "在魚游到中間釣線下方時，點擊畫面！"; const fish = document.createElement('div'); fish.textContent = '🐟'; fish.className = 'fish'; fish.style.top = `${30 + Math.random() * 50}%`; const moveDuration = 2 + Math.random() * 2; fish.style.animation = `moveFish ${moveDuration}s linear infinite alternate`; minigameArea.appendChild(fish); const style = document.createElement('style'); style.innerHTML = `@keyframes moveFish { 0% { left: 5%; transform: scaleX(1); } 49% {transform: scaleX(1);} 50% {transform: scaleX(-1);} 100% { left: 85%; transform: scaleX(-1);} }`; document.head.appendChild(style); minigameArea.onclick = () => { minigameArea.onclick = null; fish.style.animationPlayState = 'paused'; const line = document.createElement('div'); line.className = 'fishing-line'; minigameArea.appendChild(line); setTimeout(() => line.style.height = '100%', 50); setTimeout(() => { if(!minigameActive && !eventActive) return; const fishRect = fish.getBoundingClientRect(); const areaRect = minigameArea.getBoundingClientRect(); const lineX = areaRect.left + (areaRect.width / 2); try{document.head.removeChild(style);}catch(e){} const success = lineX > fishRect.left && lineX < fishRect.right; if (success) fish.classList.add('popped'); endDreamFishing(success); }, 500); }; }
    function endDreamFishing(success) { if (success) { const earnings = calculateEarnings(50 * pillowLevel); money += earnings; showEndScreen(`釣到了！一條金光閃閃的魚！獲得 ${earnings} 💰！`, `成功釣到夢境金魚，獲得 ${earnings} 💰。`, true); } else { showEndScreen(`哎呀，讓它給溜了！`, `夢境金魚逃走了，一無所獲。`, 'neutral'); } }
    function startTidyEmotions() { let score = 0; let duration = 8 + (incenseLevel - 1); showMinigame(); minigameTitle.textContent = "😊 整理情緒 😭"; minigameInstruction.textContent = "點擊笑臉 (😊) 加分，避開哭臉 (😭)！"; minigameInfoBar.innerHTML = `<span>時間: <span id="timer">${duration}</span>s</span> <span>分數: <span id="score">0</span></span>`; const timerEl = document.getElementById('timer'); const scoreEl = document.getElementById('score'); const iconSpawner = setInterval(() => { if (!minigameActive) { clearInterval(iconSpawner); return; } const isGood = Math.random() > 0.4; const icon = document.createElement('div'); icon.className = 'emotion-icon'; icon.textContent = isGood ? '😊' : '😭'; icon.style.left = `${Math.random() * 90}%`; icon.style.animationDuration = `${2 + Math.random() * 2}s`; icon.onclick = () => { if(!minigameActive) return; score += isGood ? 1 : -2; scoreEl.textContent = score; icon.onclick = null; icon.classList.add('popped'); setTimeout(() => icon.remove(), 300); }; minigameArea.appendChild(icon); setTimeout(() => icon.remove(), 4000); }, 600); gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); clearInterval(iconSpawner); endTidyEmotions(score); } }, 1000); }
    function endTidyEmotions(finalScore) { const earnings = calculateEarnings(finalScore * pillowLevel * 3); if (earnings >= 0) { money += earnings; showEndScreen(`整理完畢！心情變好了。獲得了 ${earnings} 💰。`, `你整理了情緒，獲得 ${earnings} 💰。`, true); } else { const loss = calculateEarnings(Math.abs(finalScore * 5), true); money = Math.max(0, money - loss); showEndScreen(`整理失敗，心情更亂了...損失了 ${loss} 💰。`, `整理情緒失敗，損失 ${loss} 💰。`, false); } }
    function startMazeQTE() { showMinigame(); minigameTitle.textContent = "👻 迷宮岔路 👻"; minigameInstruction.textContent = "快！按下對應的方向鍵！"; minigameArea.style.display = 'flex'; minigameArea.style.flexDirection = 'column'; minigameArea.style.justifyContent = 'center'; minigameArea.innerHTML = `<div id="qte-arrow" style="font-size: 6em; color: yellow; text-shadow: 0 0 10px black;"></div><div id="qte-timer-bar-container"><div id="qte-timer-bar"></div></div>`; const qteArrow = document.getElementById('qte-arrow'); const timerBar = document.getElementById('qte-timer-bar'); const arrows = { 'ArrowUp': '⬆️', 'ArrowDown': '⬇️', 'ArrowLeft': '⬅️', 'ArrowRight': '➡️' }; const keys = Object.keys(arrows); const correctKey = keys[Math.floor(Math.random() * keys.length)]; qteArrow.textContent = arrows[correctKey]; setTimeout(() => { timerBar.style.width = '0%'; }, 100); gameTimeout = setTimeout(() => endMazeQTE(false), 2000 + (incenseLevel * 100)); keydownHandler = (e) => { if (keys.includes(e.key)) { e.preventDefault(); endMazeQTE(e.key === correctKey); } }; document.addEventListener('keydown', keydownHandler); if(isTouchDevice) { mobileControlsContainer.innerHTML = `<button class="mobile-btn" data-key="ArrowUp">⬆️</button><button class="mobile-btn" data-key="ArrowLeft">⬅️</button><button class="mobile-btn" data-key="ArrowDown">⬇️</button><button class="mobile-btn" data-key="ArrowRight">➡️</button>`; mobileControlsContainer.classList.add('visible'); mobileControlsContainer.onclick = (e) => { if(e.target.dataset.key) { endMazeQTE(e.target.dataset.key === correctKey); } } } }
    function endMazeQTE(success) { minigameArea.style.display = 'block'; const flash = document.createElement('div'); flash.className = 'screen-flash'; flash.style.backgroundColor = success ? 'rgba(144, 238, 144, 0.5)' : 'rgba(255, 99, 71, 0.5)'; document.body.appendChild(flash); setTimeout(() => flash.remove(), 400); if (success) { showEndScreen("選對了路！暫時安全了。", "在迷宮中選對了方向，有驚無險。", true); } else { const moneyLost = calculateEarnings(50, true); money = Math.max(0, money - moneyLost); showEndScreen(`是死路！你迷失在其中...損失了 ${moneyLost} 💰。`, `在迷宮中走錯了路，損失 ${moneyLost} 💰。`, false); } }
    function startDodgeShadows() { let duration = 10; showMinigame(); minigameTitle.textContent = "👻 躲避陰影 👻"; minigameInstruction.textContent = "移動滑鼠或手指，控制光球躲避掉落的陰影！"; minigameInfoBar.innerHTML = `<span>撐住: <span id="timer">${duration}</span>s</span>`; const timerEl = document.getElementById('timer'); const player = document.createElement('div'); player.id = 'player-avatar'; minigameArea.appendChild(player); const movePlayer = (clientX) => { const areaRect = minigameArea.getBoundingClientRect(); player.style.left = `${clientX - areaRect.left - player.offsetWidth / 2}px`; }; mousemoveHandler = (e) => movePlayer(e.clientX); touchMoveHandler = (e) => { e.preventDefault(); if (e.touches[0]) movePlayer(e.touches[0].clientX); }; minigameArea.addEventListener('mousemove', mousemoveHandler); minigameArea.addEventListener('touchmove', touchMoveHandler, { passive: false }); const shadowSpawner = setInterval(() => { if (!minigameActive) { clearInterval(shadowSpawner); return; } const shadow = document.createElement('div'); shadow.className = 'shadow-obstacle'; shadow.style.left = `${Math.random() * 90}%`; shadow.style.animationDuration = `${1.2 + Math.random()}s`; minigameArea.appendChild(shadow); const checkCollision = setInterval(() => { if (!minigameActive) { clearInterval(checkCollision); return; } const playerRect = player.getBoundingClientRect(); const shadowRect = shadow.getBoundingClientRect(); if (playerRect.left < shadowRect.right && playerRect.right > shadowRect.left && playerRect.top < shadowRect.bottom && playerRect.bottom > shadowRect.top) { clearInterval(checkCollision); clearInterval(shadowSpawner); endDodgeShadows(false); } }, 50); setTimeout(() => { clearInterval(checkCollision); shadow.remove(); }, 2200); }, 400); gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); clearInterval(shadowSpawner); endDodgeShadows(true); } }, 1000); }
    function endDodgeShadows(survived) { if (!minigameActive) return; if (survived) { showEndScreen("你成功活了下來！天亮了。", "你在陰影中存活了下來，毫髮無傷。", true); } else { const moneyLost = calculateEarnings(60, true); money = Math.max(0, money - moneyLost); showEndScreen(`被陰影抓住了！損失了 ${moneyLost} 💰。`, `你被陰影吞噬，損失了 ${moneyLost} 💰。`, false); } }
    function startDreamWeaving() { let score = 0; let duration = 15 + (incenseLevel - 1); let currentLevel = 0; let requiredClicks = 0; showMinigame(); minigameTitle.textContent = "✨ 夢境編織 ✨"; minigameInstruction.textContent = "依序點擊數字，將夢境碎片連接起來。"; minigameInfoBar.innerHTML = `<span>時間: <span id="timer">${duration}</span>s</span> <span>分數: <span id="score">0</span></span>`; const timerEl = document.getElementById('timer'); const scoreEl = document.getElementById('score'); function nextLevel() { minigameArea.innerHTML = ''; currentLevel++; requiredClicks = 0; let fragmentPositions = []; const numFragments = 2 + currentLevel; const minDistance = 15; for (let i = 1; i <= numFragments; i++) { let pos; let validPosition = false; let attempts = 0; while (!validPosition && attempts < 100) { pos = { top: 10 + Math.random() * 75, left: 10 + Math.random() * 80 }; validPosition = true; for (const existingPos of fragmentPositions) { const dist = Math.sqrt(Math.pow(pos.top - existingPos.top, 2) + Math.pow(pos.left - existingPos.left, 2)); if (dist < minDistance) { validPosition = false; break; } } attempts++; } fragmentPositions.push(pos); const fragment = document.createElement('div'); fragment.className = 'dream-fragment'; fragment.textContent = i; fragment.style.top = `${pos.top}%`; fragment.style.left = `${pos.left}%`; fragment.onclick = () => onFragmentClick(fragment, i); minigameArea.appendChild(fragment); } } function onFragmentClick(element, num) { if (!minigameActive || num !== requiredClicks + 1) return; requiredClicks++; element.classList.add('clicked'); element.onclick = null; if (requiredClicks === (2 + currentLevel)) { score++; scoreEl.textContent = score; nextLevel(); } } gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); endDreamWeaving(score); } }, 1000); nextLevel(); }
    function endDreamWeaving(finalScore) { const earnings = calculateEarnings(finalScore * finalScore * pillowLevel * 2); money += earnings; showEndScreen(`編織完成！你完成了 ${finalScore} 個星座。獲得 ${earnings} 💰！`, `你在夢中編織了 ${finalScore} 個星座，獲得 ${earnings} 💰。`, true); }
    function startSleepParalysis() { let progress = 0; let duration = 10; let isHolding = false; showMinigame(); minigameTitle.textContent = "👻 鬼壓床 👻"; minigameInstruction.textContent = "按住 [空白鍵] 或下方按鈕來積蓄意志力，但要避開恐懼的脈衝！"; minigameInfoBar.innerHTML = `<span>剩餘時間: <span id="timer">${duration}</span>s</span>`; minigameArea.innerHTML = '<div id="paralysis-bar-container"><div id="paralysis-bar"></div></div><div id="paralysis-pulse"></div>'; const timerEl = document.getElementById('timer'); const bar = document.getElementById('paralysis-bar'); const pulse = document.getElementById('paralysis-pulse'); let isPulsing = false; const pulseCheck = setInterval(() => { isPulsing = parseFloat(getComputedStyle(pulse).opacity) > 0.5; }, 50); keydownHandler = e => { if (e.code === 'Space') { e.preventDefault(); if(!isHolding) isHolding = true; } }; keyupHandler = e => { if (e.code === 'Space') { e.preventDefault(); isHolding = false; } }; document.addEventListener('keydown', keydownHandler); document.addEventListener('keyup', keyupHandler); if(isTouchDevice) { mobileControlsContainer.innerHTML = `<button id="mobile-hold-button">按住</button>`; mobileControlsContainer.classList.add('visible'); const holdButton = document.getElementById('mobile-hold-button'); touchStartHandler = e => { e.preventDefault(); isHolding = true; }; touchEndHandler = e => { e.preventDefault(); isHolding = false; }; holdButton.addEventListener('touchstart', touchStartHandler, { passive: false }); holdButton.addEventListener('touchend', touchEndHandler, { passive: false }); } gameInterval = setInterval(() => { if (isHolding) { if (isPulsing) { progress -= 10; } else { progress += 2.5 + (incenseLevel - 1) * 0.2; } } else { progress -= 0.5; } progress = Math.max(0, Math.min(100, progress)); bar.style.width = `${progress}%`; if (progress >= 100) { clearInterval(gameInterval); clearInterval(pulseCheck); endSleepParalysis(true); return; } duration -= 0.05; timerEl.textContent = Math.ceil(duration); if (duration <= 0) { clearInterval(gameInterval); clearInterval(pulseCheck); endSleepParalysis(false); } }, 50); }
    function endSleepParalysis(success) { if (success) { showEndScreen("你戰勝了恐懼，成功醒來！", "你從鬼壓床中成功掙脫，有驚無險。", true); } else { const moneyLost = calculateEarnings(70, true); money = Math.max(0, money - moneyLost); showEndScreen(`意志力耗盡...你被困在了恐懼中。損失 ${moneyLost} 💰。`, `被鬼壓床擊敗，損失了 ${moneyLost} 💰。`, false); } }
    
    // --- 7. 遊戲初始化 ---
    document.addEventListener('DOMContentLoaded', () => {
        gameContainer = document.getElementById('game-container'); nexusContainer = document.getElementById('nexus-container'); dayCountEl = document.getElementById('day-count'); moneyEl = document.getElementById('money'); goodDreamChanceEl = document.getElementById('good-dream-chance'); gameLogEl = document.getElementById('game-log'); sleepButton = document.getElementById('sleep-button'); bedLevelEl = document.getElementById('bed-level'); pillowLevelEl = document.getElementById('pillow-level'); dreamCatcherLevelEl = document.getElementById('dreamcatcher-level'); incenseLevelEl = document.getElementById('incense-level'); bedUpgradeCostEl = document.getElementById('bed-upgrade-cost'); pillowUpgradeCostEl = document.getElementById('pillow-upgrade-cost'); dreamCatcherUpgradeCostEl = document.getElementById('dreamcatcher-upgrade-cost'); incenseUpgradeCostEl = document.getElementById('incense-upgrade-cost'); upgradeBedButton = document.getElementById('upgrade-bed-button'); upgradePillowButton = document.getElementById('upgrade-pillow-button'); upgradeDreamCatcherButton = document.getElementById('upgrade-dreamcatcher-button'); upgradeIncenseButton = document.getElementById('upgrade-incense-button'); minigameModal = document.getElementById('minigame-modal'); minigameTitle = minigameModal.querySelector('h3'); minigameInstruction = minigameModal.querySelector('p'); minigameInfoBar = minigameModal.querySelector('#minigame-info-bar'); minigameArea = minigameModal.querySelector('#minigame-area'); minigameResultEl = minigameModal.querySelector('#minigame-result'); mobileControlsContainer = minigameModal.querySelector('#mobile-controls-container'); eventModal = document.getElementById('event-modal'); eventResultEl = eventModal.querySelector('#event-result'); cardContainer = document.getElementById('card-container'); goodDreamItemCostEl = document.getElementById('good-dream-item-cost'); badDreamItemCostEl = document.getElementById('bad-dream-item-cost'); buyGoodDreamItemButton = document.getElementById('buy-good-dream-item-button'); buyBadDreamItemButton = document.getElementById('buy-bad-dream-item-button'); merchantModal = document.getElementById('merchant-modal'); merchantTimerEl = document.getElementById('merchant-timer'); merchantItemsEl = merchantModal.querySelector('#merchant-items'); potionEffectStatusEl = document.getElementById('potion-effect-status'); settingsButton = document.getElementById('settings-button'); settingsModal = document.getElementById('settings-modal'); deleteSaveButton = document.getElementById('delete-save-button'); settingsCloseButton = document.getElementById('settings-close-button'); storyModal = document.getElementById('story-modal'); storyModalTitle = document.getElementById('story-modal-title'); storyModalText = document.getElementById('story-modal-text'); storyModalCloseButton = document.getElementById('story-modal-close-button'); endingModal = document.getElementById('ending-modal'); endingText = document.getElementById('ending-text'); endingResetButton = document.getElementById('ending-reset-button'); endingContinueButton = document.getElementById('ending-continue-button'); backpackButton = document.getElementById('backpack-button'); backpackModal = document.getElementById('backpack-modal'); backpackItemsEl = document.getElementById('backpack-items'); backpackCloseButton = document.getElementById('backpack-close-button'); nexusPortalButton = document.getElementById('nexus-portal-button'); alertModal = document.getElementById('alert-modal'); alertText = document.getElementById('alert-text'); alertCloseButton = document.getElementById('alert-close-button');
        endingModal2 = document.getElementById('ending-modal-2'); endingResetButton2 = document.getElementById('ending-reset-button-2'); endingContinueButton2 = document.getElementById('ending-continue-button-2');
        bgmEl = document.getElementById('bgm'); volumeSliderEl = document.getElementById('volume-slider');

        function initAudio() {
            const playMusicOnClick = () => {
                bgmEl.play().catch(e => console.log("用戶互動後，音訊播放失敗:", e));
                document.removeEventListener('click', playMusicOnClick);
                document.removeEventListener('keydown', playMusicOnClick);
            };
            document.addEventListener('click', playMusicOnClick);
            document.addEventListener('keydown', playMusicOnClick);
        }

        sleepButton.addEventListener('click', goToSleep); upgradeBedButton.addEventListener('click', upgradeBed); upgradePillowButton.addEventListener('click', upgradePillow); upgradeDreamCatcherButton.addEventListener('click', upgradeDreamCatcher); upgradeIncenseButton.addEventListener('click', upgradeIncense);
        buyGoodDreamItemButton.addEventListener('click', () => buyItem('luckyClover', goodDreamItemCost));
        buyBadDreamItemButton.addEventListener('click', () => buyItem('cursedDoll', badDreamItemCost));
        settingsButton.addEventListener('click', () => { settingsModalActive = true; settingsModal.classList.remove('hidden'); updateStatsUI(); });
        settingsCloseButton.addEventListener('click', () => { settingsModalActive = false; settingsModal.classList.add('hidden'); saveGame(); updateStatsUI(); });
        deleteSaveButton.addEventListener('click', deleteSaveAndReset);
        storyModalCloseButton.addEventListener('click', () => { storyModalActive = false; storyModal.classList.add('hidden'); gameContainer.classList.remove('frozen'); saveGameAndUpdateUI(); });
        endingResetButton.addEventListener('click', deleteSaveAndReset);
        endingContinueButton.addEventListener('click', () => { endingActive = false; endingModal.classList.add('hidden'); gameContainer.classList.remove('frozen'); saveGameAndUpdateUI(); });
        endingResetButton2.addEventListener('click', deleteSaveAndReset);
        endingContinueButton2.addEventListener('click', () => { endingActive = false; endingModal2.classList.add('hidden'); gameContainer.classList.remove('frozen'); saveGameAndUpdateUI(); });
        backpackButton.addEventListener('click', openBackpack);
        backpackCloseButton.addEventListener('click', closeBackpack);
        backpackItemsEl.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.itemId) { useItem(e.target.dataset.itemId); } });
        nexusPortalButton.addEventListener('click', () => { if (dayCount >= 100) { switchView('nexus'); } else { showAlert(`夢境的核心尚未穩固，似乎需要經歷更多時日才能一探究竟。\n(100天後解鎖)`); } });
        alertCloseButton.addEventListener('click', () => { alertModalActive = false; alertModal.classList.add('hidden'); updateStatsUI(); });
        volumeSliderEl.addEventListener('input', (e) => { musicVolume = parseFloat(e.target.value); bgmEl.volume = musicVolume; });

        loadGame();
        initNexusCanvas();
        initAudio();
        switchView(currentView);
        updateStatsUI(); 
        mainEventInterval = setInterval(triggerRandomEvent, 60000);
    });

    // --- 8. Canvas Logic ---
    function initNexusCanvas() {
        const canvas = document.getElementById('nexusCanvas');
        if (!canvas) return;
        let nexusAnimationId = null;
        const ctx = canvas.getContext('2d');
        let time = 0;
        const stars = [];
        for (let i = 0; i < 300; i++) { const layer = Math.random() > 0.9 ? 1 : (Math.random() > 0.6 ? 2 : 3); stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: layer === 1 ? Math.random() * 2 : (layer === 2 ? Math.random() * 1.5 : Math.random() * 1), alpha: layer === 1 ? 1 : (layer === 2 ? 0.7 : 0.4), speed: layer === 1 ? 0.2 : (layer === 2 ? 0.1 : 0.05), }); }
        const comets = []; const bubbles = [];
        function createCracks(x, y, width, height) { const cracks = []; const centerX = x + width / 2; const centerY = y + height / 2; for (let i = 0; i < 3; i++) { const angle = Math.random() * Math.PI * 2; const endX = x + Math.random() * width; const endY = y + Math.random() * height; const path = [{x: centerX, y: centerY}]; let currentX = centerX; let currentY = centerY; const dist = Math.sqrt(Math.pow(endX - centerX, 2) + Math.pow(endY - centerY, 2)); const steps = Math.floor(dist / 10); for(let j=0; j<steps; j++){ const targetAngle = Math.atan2(endY - currentY, endX - currentX); const newAngle = targetAngle + (Math.random() - 0.5) * 0.8; currentX += Math.cos(newAngle) * 10; currentY += Math.sin(newAngle) * 10; if (currentX > x && currentX < x + width && currentY > y && currentY < y + height) { path.push({x: currentX, y: currentY}); } else { break; } } cracks.push(path); } return cracks; }
        const interactiveElements = [ { name: "記憶之鏡", x: 350, y: 150, width: 100, height: 150, hovered: false, cracks: createCracks(350, 150, 100, 150), shiningShard: null, init() { const shardCount = Math.floor(Math.random() * 3) + 2; this.shards = []; for(let i=0; i<shardCount; i++) { const path = new Path2D(); path.moveTo(this.x + Math.random() * this.width, this.y + Math.random() * this.height); for(let j=0; j<3; j++) { path.lineTo(this.x + Math.random() * this.width, this.y + Math.random() * this.height); } path.closePath(); this.shards.push(path); } this.shiningShard = this.shards[Math.floor(Math.random() * this.shards.length)]; }, draw(ctx) { ctx.strokeStyle = this.hovered ? 'white' : '#aaa'; ctx.lineWidth = 3; ctx.shadowColor = this.hovered ? 'cyan' : 'transparent'; ctx.shadowBlur = this.hovered ? 20 : 0; ctx.strokeRect(this.x, this.y, this.width, this.height); if (this.hovered && this.shiningShard) { ctx.save(); ctx.clip(this.shiningShard); ctx.fillStyle = `rgba(0, 255, 255, ${0.3 + Math.sin(time * 2) * 0.2})`; ctx.shadowColor = 'cyan'; ctx.shadowBlur = 20; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.restore(); } ctx.shadowBlur = 0; ctx.strokeStyle = '#888'; ctx.lineWidth = 1; this.cracks.forEach(path => { ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for(let i=1; i<path.length; i++) { ctx.lineTo(path[i].x, path[i].y); } ctx.stroke(); }); } }, { name: "奇想花園", x: 100, y: 350, width: 120, height: 100, hovered: false, glow: 0, draw(ctx) { ctx.fillStyle = this.hovered ? '#e94560' : '#8B4513'; ctx.shadowColor = this.hovered ? 'magenta' : 'transparent'; ctx.shadowBlur = this.hovered ? 20 : 0; ctx.beginPath(); ctx.moveTo(this.x, this.y + this.height); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.lineTo(this.x + this.width - 20, this.y + this.height - 40); ctx.lineTo(this.x + 20, this.y + this.height - 40); ctx.closePath(); ctx.fill(); const shadowBlur = 15 + this.glow * 10; const radius = 18 + this.glow * 2; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height - 70, radius, 0, Math.PI * 2); ctx.shadowColor = 'rgba(255, 255, 0, 0.7)'; ctx.shadowBlur = shadowBlur; ctx.fillStyle = 'rgba(255, 255, 224, 0.8)'; ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = '#f0ad4e'; ctx.fill(); } }, { name: "煉金工坊", x: 580, y: 340, width: 100, height: 110, hovered: false, draw(ctx) { const flaskX = this.x + this.width / 2; const flaskBottomY = this.y + this.height; const flaskRadius = 30; ctx.save(); ctx.fillStyle = this.hovered ? 'rgba(63, 114, 175, 0.8)' : 'rgba(63, 114, 175, 0.5)'; ctx.shadowColor = this.hovered ? 'rgba(63, 114, 175, 1)' : 'rgba(63, 114, 175, 0.5)'; ctx.shadowBlur = this.hovered ? 25 : 15; ctx.beginPath(); ctx.arc(flaskX, flaskBottomY - flaskRadius, flaskRadius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); ctx.strokeStyle = this.hovered ? 'white' : '#aaa'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(flaskX, flaskBottomY - flaskRadius, flaskRadius, 0, Math.PI, true); ctx.moveTo(flaskX - flaskRadius, flaskBottomY - flaskRadius); ctx.lineTo(flaskX - 15, flaskBottomY - flaskRadius); ctx.lineTo(flaskX - 15, this.y); ctx.moveTo(flaskX + 15, this.y); ctx.lineTo(flaskX + 15, flaskBottomY - flaskRadius); ctx.lineTo(flaskX + flaskRadius, flaskBottomY - flaskRadius); ctx.stroke(); ctx.beginPath(); ctx.arc(flaskX - 10, flaskBottomY - flaskRadius - 10, 8, Math.PI * 1.2, Math.PI * 1.8); ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth = 2; ctx.stroke(); } }, { name: "清醒技能樹", x: 600, y: 180, width: 100, height: 100, hovered: false, draw(ctx) { ctx.shadowColor = this.hovered ? 'yellow' : 'transparent'; ctx.shadowBlur = this.hovered ? 20 : 0; const drawNode = (x, y, radius, color) => { ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); }; const centerX = this.x + this.width/2; const centerY = this.y + this.height/2; ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(centerX - 40, centerY - 40); ctx.moveTo(centerX, centerY); ctx.lineTo(centerX + 40, centerY - 30); ctx.moveTo(centerX, centerY); ctx.lineTo(centerX, centerY + 50); ctx.stroke(); drawNode(centerX, centerY, 10, '#f0ad4e'); drawNode(centerX - 40, centerY - 40, 6, '#aaa'); drawNode(centerX + 40, centerY - 30, 6, '#aaa'); drawNode(centerX, centerY + 50, 6, '#aaa'); } }, { name: "返回夢境", x: 350, y: 400, width: 100, height: 150, hovered: false, draw(ctx) { ctx.fillStyle = '#000'; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeStyle = this.hovered ? '#e94560' : '#888'; ctx.lineWidth = 4; ctx.shadowColor = this.hovered ? '#e94560' : 'transparent'; ctx.shadowBlur = this.hovered ? 20 : 0; ctx.strokeRect(this.x, this.y, this.width, this.height); if(this.hovered) { ctx.fillStyle = "rgba(233, 69, 96, 0.3)"; ctx.fillRect(this.x + 10, this.y + 10, this.width - 20, this.height - 20); } } } ];
        interactiveElements.find(el => el.name === "記憶之鏡").init();
        
        function getCanvasCoordinates(x, y) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (x - rect.left) * scaleX,
                y: (y - rect.top) * scaleY
            };
        }
        
        function updateHoveredElement(x, y) {
            const coords = getCanvasCoordinates(x, y);
            let elementFound = false;
            interactiveElements.forEach(el => {
                const isHovered = coords.x >= el.x && coords.x <= el.x + el.width && coords.y >= el.y && coords.y <= el.y + el.height;
                if (el.hovered !== isHovered) {
                    el.hovered = isHovered;
                }
                if(isHovered) elementFound = true;
            });
            canvas.style.cursor = elementFound ? 'pointer' : 'default';
        }

        function handleMouseMove(e) {
            updateHoveredElement(e.clientX, e.clientY);
        }
        
        function handleTouch(e) {
            e.preventDefault();
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                updateHoveredElement(touch.clientX, touch.clientY);
            }
        }

        function handleCanvasClick(e) {
            const coords = getCanvasCoordinates(e.clientX, e.clientY);
            const clickedElement = interactiveElements.find(el => coords.x >= el.x && coords.x <= el.x + el.width && coords.y >= el.y && coords.y <= el.y + el.height);

            if (clickedElement) {
                if (clickedElement.name === "返回夢境") {
                    switchView('dream_room');
                } else {
                    showAlert(`【${clickedElement.name}】的功能尚未開放。`);
                }
            }
        }

        function clearHover() {
            interactiveElements.forEach(el => { el.hovered = false; });
            canvas.style.cursor = 'default';
        }

        function spawnComet() { if (Math.random() < 0.005 && comets.length < 3) { comets.push({ x: Math.random() * canvas.width + canvas.width / 2, y: -100, length: Math.random() * 200 + 100, speed: Math.random() * 2 + 1, opacity: 1 }); } }
        function spawnBubble() { if(Math.random() < 0.1) { const flask = interactiveElements.find(el => el.name === "煉金工坊"); if(flask) { bubbles.push({ x: flask.x + flask.width/2 + (Math.random() - 0.5) * 30, y: flask.y + flask.height - 30, radius: Math.random() * 2 + 1, speed: Math.random() * 0.5 + 0.2 }); } } }
        
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height); bgGrad.addColorStop(0, '#1a1a2e'); bgGrad.addColorStop(1, '#0f1c2e'); ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, canvas.width, canvas.height);
            stars.forEach(star => { ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`; ctx.fill(); });
            comets.forEach(comet => { const grad = ctx.createLinearGradient(comet.x, comet.y, comet.x - comet.length, comet.y + comet.length); grad.addColorStop(0, `rgba(255, 255, 255, ${comet.opacity})`); grad.addColorStop(1, 'rgba(255, 255, 255, 0)'); ctx.beginPath(); ctx.moveTo(comet.x, comet.y); ctx.lineTo(comet.x - comet.length, comet.y + comet.length); ctx.strokeStyle = grad; ctx.lineWidth = 2; ctx.stroke(); });
            const islandOffsetY = Math.sin(time * 0.5) * 5; 
            ctx.beginPath(); ctx.ellipse(canvas.width / 2, canvas.height + 300 + islandOffsetY, 500, 400, 0, 0, Math.PI * 2); ctx.fillStyle = '#16213e'; ctx.fill(); ctx.strokeStyle = '#0f3460'; ctx.lineWidth = 5; ctx.stroke();
            
            interactiveElements.forEach(el => {
                ctx.save();
                el.draw(ctx);
                ctx.restore();
            });

            bubbles.forEach(bubble => { ctx.beginPath(); ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2); ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; ctx.fill(); });
            const hoveredElement = interactiveElements.find(el => el.hovered);
            if (hoveredElement) { ctx.font = "bold 20px 'Microsoft JhengHei'"; ctx.fillStyle = "white"; ctx.textAlign = 'center'; ctx.shadowColor = 'black'; ctx.shadowBlur = 5; ctx.fillText(hoveredElement.name, hoveredElement.x + hoveredElement.width / 2, hoveredElement.y - 15); }
        }

        function animate() {
            nexusAnimationId = requestAnimationFrame(animate);
            time += 0.05;
            stars.forEach(star => { star.x -= star.speed; if (star.x < 0) { star.x = canvas.width; } });
            comets.forEach((comet, index) => { comet.x -= comet.speed; comet.y += comet.speed; if (comet.x < -comet.length) { comets.splice(index, 1); } });
            spawnComet();
            bubbles.forEach((bubble, index) => { bubble.y -= bubble.speed; if(bubble.y < 380) { bubbles.splice(index, 1); } });
            spawnBubble();
            const garden = interactiveElements.find(el => el.name === "奇想花園");
            if (garden) { garden.glow = (Math.sin(time) + 1) / 2; }
            drawScene();
        }
        
        initNexusCanvas.start = () => {
            if (!nexusAnimationId) {
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('touchstart', handleTouch, { passive: false });
                canvas.addEventListener('touchmove', handleTouch, { passive: false });
                canvas.addEventListener('touchend', clearHover);
                canvas.addEventListener('touchcancel', clearHover);
                canvas.addEventListener('click', handleCanvasClick);
                animate();
            }
        };
        initNexusCanvas.stop = () => {
            if (nexusAnimationId) {
                cancelAnimationFrame(nexusAnimationId);
                nexusAnimationId = null;
                canvas.removeEventListener('mousemove', handleMouseMove);
                canvas.removeEventListener('touchstart', handleTouch);
                canvas.removeEventListener('touchmove', handleTouch);
                canvas.removeEventListener('touchend', clearHover);
                canvas.removeEventListener('touchcancel', clearHover);
                canvas.removeEventListener('click', handleCanvasClick);
                clearHover();
            }
        };
    }
    </script>
</body>
</html>