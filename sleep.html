<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤¢å¢ƒéŠæˆ² - ç™¾æ—¥å¤¢</title>
    
    <style>
        :root { --dark-bg: #1a1a2e; --container-bg: #16213e; --border-color: #0f3460; --primary-text: #e0e0e0; --highlight-color: #e94560; --good-color: #3f72af; --bad-color: #d9534f; --neutral-color: #f0ad4e; }
        body { font-family: 'Microsoft JhengHei', 'Arial', sans-serif; background-color: var(--dark-bg); color: var(--primary-text); display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; }
        #game-container { position: relative; width: 90%; max-width: 700px; background-color: var(--container-bg); padding: 25px; border-radius: 15px; box-shadow: 0 0 20px rgba(255, 255, 255, 0.1); border: 1px solid var(--border-color); transition: filter 0.3s, transform 0.3s; z-index: 10; }
        #game-container.frozen { filter: blur(5px); transform: scale(0.98); pointer-events: none; }
        h1, h2 { text-align: center; color: var(--highlight-color); text-shadow: 0 0 5px var(--highlight-color); }
        #player-stats { display: flex; justify-content: space-around; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; font-size: 1.1em; flex-wrap: wrap; }
        #game-log { background-color: #0f1c2e; border: 1px solid var(--border-color); padding: 15px; height: 150px; overflow-y: scroll; margin-bottom: 20px; border-radius: 5px; scroll-behavior: smooth; }
        button { padding: 12px 25px; font-size: 18px; font-weight: bold; cursor: pointer; border: none; border-radius: 8px; background-color: var(--highlight-color); color: white; transition: background-color 0.3s, transform 0.1s; user-select: none; -webkit-tap-highlight-color: transparent; }
        button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.7; }
        button:not(:disabled):active { transform: translateY(1px); }
        .upgrade-item { background-color: rgba(255, 255, 255, 0.05); border: 1px solid var(--border-color); padding: 15px; margin-bottom: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        .upgrade-item div { flex-basis: 70%; } .upgrade-item button { flex-basis: 25%; } .upgrade-item p { margin: 2px 0; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.3s; background-color: rgba(0, 0, 0, 0.7); }
        .modal:not(.hidden) { opacity: 1; pointer-events: all; }
        .modal-content { background-color: var(--container-bg); padding: 30px; border-radius: 15px; border: 1px solid var(--border-color); width: 90%; max-width: 500px; text-align: center; transform: scale(0.9); transition: transform 0.3s; position: relative; }
        .modal:not(.hidden) .modal-content { transform: scale(1); }
        #minigame-instruction, #event-instruction { min-height: 20px; color: var(--neutral-color); margin-top: 0; }
        #minigame-info-bar { display: flex; justify-content: space-around; font-size: 1.2em; font-weight: bold; margin-bottom: 15px; min-height: 25px; }
        #minigame-area { position: relative; width: 100%; height: 250px; background-color: #0f1c2e; border-radius: 10px; margin: 15px 0; overflow: hidden; user-select: none; }
        #minigame-result { font-size: 1.5em; margin-top: 20px; font-weight: bold; min-height: 50px; transition: color 0.3s; }
        #potion-effect-status { text-align: center; color: var(--neutral-color); min-height: 20px; margin-bottom: 15px; font-weight: bold; }
        #settings-area { position: absolute; top: 15px; right: 15px; }
        #settings-button { font-size: 1.2em; padding: 5px 10px; background: none; border: 1px solid var(--border-color); }
        #story-modal-text { font-size: 1.2em; line-height: 1.6; margin-bottom: 25px; }
        #ending-modal .modal-content { background: linear-gradient(180deg, #1a1a2e, #0f1c2e); border-color: #e94560; }
        #ending-title { font-size: 2.5em; color: var(--highlight-color); }
        #ending-text { font-size: 1.2em; margin: 20px 0; }
        #ending-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 25px; }
        #ending-continue-button { background-color: var(--good-color); }
        #backpack-items .upgrade-item div { flex-basis: 60%; }
        #backpack-items .upgrade-item button { flex-basis: 35%; }
        #mobile-controls-container { display: none; margin-top: 15px; }
        #mobile-controls-container.visible { display: flex; justify-content: space-around; align-items: center; }
        .mobile-btn { flex-grow: 1; margin: 0 5px; padding: 15px 10px; font-size: 2em; background-color: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.4); }
        #mobile-hold-button { width: 80%; padding: 20px; font-size: 1.5em; background-color: var(--good-color); }
        .meteor { position: fixed; font-size: 2em; color: yellow; text-shadow: 0 0 10px orange; user-select: none; pointer-events: auto; cursor: pointer; z-index: 1002; } @keyframes fall-meteor { 0% { transform: translate(0, 0) rotate(-45deg); opacity: 1; } 100% { transform: translate(-100vw, 100vh) rotate(-45deg); opacity: 0; } } #card-container { display: flex; justify-content: space-around; perspective: 1000px; margin-top: 20px; } .card { width: 100px; height: 150px; cursor: pointer; } .card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; } .card.is-flipped .card-inner { transform: rotateY(180deg); } .card-face { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; border-radius: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 10px; box-sizing: border-box; } .card-back { background: linear-gradient(45deg, #6d6d6d, #4f4f4f); font-size: 3em; color: var(--neutral-color); } .card-front { background-color: #eee; color: #333; transform: rotateY(180deg); } .fortune-name { font-size: 2em; font-weight: bold; } .fortune-tagline { font-size: 0.9em; margin-top: 10px; } .star { position: absolute; font-size: 3em; cursor: pointer; user-select: none; } .emotion-icon { position: absolute; font-size: 3.5em; cursor: pointer; user-select: none; animation: fall linear forwards; } .star.popped, .emotion-icon.popped, .fish.popped, .meteor.popped { animation: pop 0.3s ease-out forwards; } @keyframes pop { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(2.5); opacity: 0; } } @keyframes fall { 0% { top: -50px; } 100% { top: 250px; } }
        #qte-timer-bar-container { width: 100%; height: 10px; background-color: #555; border-radius: 5px; margin-top: 10px; } #qte-timer-bar { width: 100%; height: 100%; background-color: var(--neutral-color); border-radius: 5px; transition: width 2s linear; } .screen-flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1001; pointer-events: none; animation: flash-anim 0.4s ease-out; } @keyframes flash-anim { from { opacity: 0.7; } to { opacity: 0; } } #player-avatar, .shadow-obstacle { position: absolute; } #player-avatar { bottom: 10px; width: 30px; height: 30px; background-color: var(--good-color); border-radius: 50%; box-shadow: 0 0 10px white; } #player-avatar.hit { animation: player-hit 0.5s; } @keyframes player-hit { 50% { background-color: var(--bad-color); transform: scale(1.2); } } .shadow-obstacle { width: 40px; height: 40px; background-color: #444; border-radius: 10px; animation: fall linear forwards; } .fishing-line { position: absolute; width: 2px; height: 0; background-color: white; top: 0; left: 50%; transition: height 0.3s ease-out; } .fish { position: absolute; font-size: 2em; } .memory-star { position: absolute; font-size: 2.5em; cursor: pointer; transition: transform 0.2s, text-shadow 0.2s; } .memory-star.highlight { text-shadow: 0 0 15px yellow; transform: scale(1.3); } .memory-star.wrong { animation: flash-red 0.5s; } .memory-star.correct-path { animation: flash-green 0.5s; } @keyframes flash-red { 50% { text-shadow: 0 0 15px red; } } @keyframes flash-green { 50% { text-shadow: 0 0 15px lightgreen; } } .dream-fragment { position: absolute; width: 40px; height: 40px; background-color: rgba(255, 255, 255, 0.1); border: 2px solid var(--neutral-color); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.5em; cursor: pointer; transition: background-color 0.2s; } .dream-fragment.clicked { background-color: var(--good-color); border-color: lightgreen; } #paralysis-bar-container { width: 80%; height: 40px; background-color: #0f1c2e; border: 2px solid #555; border-radius: 10px; margin: 50px auto; } #paralysis-bar { width: 0%; height: 100%; background-color: var(--good-color); border-radius: 8px; transition: width 0.1s linear; } #paralysis-pulse { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(217, 83, 79, 0.7); opacity: 0; animation: pulse-anim 1.5s ease-in-out infinite; } @keyframes pulse-anim { 5% { opacity: 1; } 25% { opacity: 0; } }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="settings-area">
            <button id="settings-button">âš™ï¸</button>
        </div>
        <h1>å¤¢å¢ƒéŠæˆ²</h1>
        <div id="player-stats">
            <p>å¤©æ•¸: <span id="day-count">0</span> â˜€ï¸</p>
            <p>é‡‘éŒ¢: <span id="money">0</span> ğŸ’°</p>
            <p>å¥½å¤¢æ©Ÿç‡: <span id="good-dream-chance">50</span>% âœ¨</p>
        </div>
        <div id="potion-effect-status"></div>
        <div id="game-log"></div>
        <div id="controls" style="text-align:center; margin-bottom:25px; display: flex; justify-content: center; gap: 20px;">
            <button id="sleep-button">å…¥ç¡</button>
            <button id="backpack-button" style="background-color: var(--good-color);">èƒŒåŒ…</button>
        </div>
        <div id="upgrades">
            <h2>å‡ç´šå•†åº—</h2>
            <div class="upgrade-item">
                <div>
                    <p><strong>å‡ç´šåºŠ</strong> (ç­‰ç´š: <span id="bed-level">1</span>)</p>
                    <p>æ•ˆæœ: +5% åŸºç¤å¥½å¤¢æ©Ÿç‡ (ä¸Šé™95%)</p>
                    <p>åƒ¹æ ¼: <span id="bed-upgrade-cost">50</span> ğŸ’°</p>
                </div>
                <button id="upgrade-bed-button">å‡ç´š</button>
            </div>
             <div class="upgrade-item">
                <div>
                    <p><strong>å‡ç´šæ•é ­</strong> (ç­‰ç´š: <span id="pillow-level">1</span>)</p>
                    <p>æ•ˆæœ: æé«˜é‡‘éŒ¢ç²å–é‡</p>
                    <p>åƒ¹æ ¼: <span id="pillow-upgrade-cost">70</span> ğŸ’°</p>
                </div>
                <button id="upgrade-pillow-button">å‡ç´š</button>
            </div>
            <div class="upgrade-item">
                <div>
                    <p><strong>è³¼è²·æ•å¤¢ç¶²</strong> (ç­‰ç´š: <span id="dreamcatcher-level">1</span>)</p>
                    <p>æ•ˆæœ: æ¸›å°‘å£å¤¢çš„é‡‘éŒ¢æå¤± (æ¯ç´š-10%)</p>
                    <p>åƒ¹æ ¼: <span id="dreamcatcher-upgrade-cost">100</span> ğŸ’°</p>
                </div>
                <button id="upgrade-dreamcatcher-button">å‡ç´š</button>
            </div>
            <div class="upgrade-item">
                <div>
                    <p><strong>è³¼è²·å¯§ç¥è–°é¦™</strong> (ç­‰ç´š: <span id="incense-level">1</span>)</p>
                    <p>æ•ˆæœ: å»¶é•·å¥½å¤¢æ™‚é–“ / é™ä½å£å¤¢é›£åº¦</p>
                    <p>åƒ¹æ ¼: <span id="incense-upgrade-cost">120</span> ğŸ’°</p>
                </div>
                <button id="upgrade-incense-button">å‡ç´š</button>
            </div>
        </div>
        <div id="item-shop">
            <h2>ç‰©å“å•†åº—</h2>
            <div class="upgrade-item">
                <div>
                    <p><strong>å¹¸é‹å››è‘‰è‰</strong> (æ•ˆæœ: ä¸‹æ¬¡å¿…å®šå¥½å¤¢)</p>
                    <p>åƒ¹æ ¼: <span id="good-dream-item-cost">150</span> ğŸ’°</p>
                </div>
                <button id="buy-good-dream-item-button">è³¼è²·</button>
            </div>
            <div class="upgrade-item">
                <div>
                    <p><strong>è©›å’’å¨ƒå¨ƒ</strong> (æ•ˆæœ: ä¸‹æ¬¡å¿…å®šå£å¤¢)</p>
                    <p>åƒ¹æ ¼: <span id="bad-dream-item-cost">50</span> ğŸ’°</p>
                </div>
                <button id="buy-bad-dream-item-button">è³¼è²·</button>
            </div>
        </div>
    </div>
    
    <div id="minigame-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="minigame-title"></h3>
            <p id="minigame-instruction"></p>
            <div id="minigame-info-bar"></div>
            <div id="minigame-area"></div>
            <div id="minigame-result"></div>
            <div id="mobile-controls-container"></div>
        </div>
    </div>

    <div id="event-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="event-title">å¤¢å¢ƒçš„å•Ÿç¤º</h3>
            <p id="event-instruction">ä¼¼ä¹æœ‰ä»€éº¼äº‹è¦ç™¼ç”Ÿäº†... è«‹é¸æ“‡ä¸€å¼µå¡ç‰Œï¼Œçœ‹çœ‹ä½ çš„é‹å‹¢ã€‚</p>
            <div id="card-container"></div>
            <p id="event-result" style="font-size: 1.2em; min-height: 40px; margin-top: 20px;"></p>
        </div>
    </div>

    <div id="merchant-modal" class="modal hidden">
        <div class="modal-content">
            <h3>ç¥ç§˜çš„å¤¢å¢ƒå•†äººå‡ºç¾äº†ï¼</h3>
            <p>ä»–å°‡åœ¨ <span id="merchant-timer"></span> ç§’å¾Œé›¢å»...</p>
            <div id="merchant-items"></div>
        </div>
    </div>

    <div id="story-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="story-modal-title"></h3>
            <p id="story-modal-text"></p>
            <button id="story-modal-close-button">ç¹¼çºŒ</button>
        </div>
    </div>

    <div id="ending-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="ending-title">ç¬¬ä¸€ç¯‡ç« ãƒ»å®Œ</h2>
            <p id="ending-text">æ„Ÿè¬æ‚¨çš„éŠç©ï¼è«‹éœå¾…ç¬¬äºŒç¯‡ç« çš„æ›´æ–°...</p>
            <div id="ending-buttons">
                <button id="ending-continue-button">ç¹¼çºŒéŠç©</button>
                <button id="ending-reset-button">é‡æ–°é–‹å§‹</button>
            </div>
        </div>
    </div>

    <div id="settings-modal" class="modal hidden">
        <div class="modal-content">
            <h2>è¨­å®š</h2>
            <p>æ‚¨ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰é€²åº¦ï¼Œå›åˆ°ç¬¬ä¸€å¤©å—ï¼Ÿæ­¤å‹•ä½œç„¡æ³•å¾©åŸã€‚</p>
            <button id="delete-save-button" style="background-color: var(--bad-color);">åˆªé™¤å­˜æª”ä¸¦é‡ç½®</button>
            <button id="settings-close-button" style="background-color: #555; margin-top: 10px;">å–æ¶ˆ</button>
        </div>
    </div>

    <div id="backpack-modal" class="modal hidden">
        <div class="modal-content">
            <h2>èƒŒåŒ…</h2>
            <div id="backpack-items" style="max-height: 400px; overflow-y: auto; padding: 10px;"></div>
            <button id="backpack-close-button" style="background-color: #555; margin-top: 20px;">é—œé–‰</button>
        </div>
    </div>

    <script>
    // --- 1. éŠæˆ²ç‹€æ…‹èˆ‡è¨­å®š ---
    let dayCount, money, baseGoodDreamChance, pillowLevel, dreamCatcherLevel, incenseLevel, bedLevel;
    let bedUpgradeCost, pillowUpgradeCost, dreamCatcherUpgradeCost, incenseUpgradeCost;
    let inventory, gameLogHTML, tempGoodDreamChanceBonus;
    let effectNextGoodDream = false, effectNextBadDream = false, activePotion = null; 

    const goodDreamItemCost = 150, badDreamItemCost = 50;
    const isTouchDevice = 'ontouchstart' in window;
    let mainScreenEventActive = false, minigameActive = false, eventActive = false, storyModalActive = false, endingActive = false, settingsModalActive = false, backpackModalActive = false;
    let gameInterval, gameTimeout, keydownHandler, keyupHandler, mousemoveHandler, touchMoveHandler, touchStartHandler, touchEndHandler, mainEventInterval;

    const itemsData = { 'luckyClover': { name: 'å¹¸é‹å››è‘‰è‰', description: 'ä½¿ç”¨å¾Œï¼Œä¸‹æ¬¡å…¥ç¡å¿…å®šæ˜¯å¥½å¤¢ã€‚' }, 'cursedDoll': { name: 'è©›å’’å¨ƒå¨ƒ', description: 'ä½¿ç”¨å¾Œï¼Œä¸‹æ¬¡å…¥ç¡å¿…å®šæ˜¯å£å¤¢ã€‚' }, 'power': { name: 'åŠ›é‡è—¥æ°´', description: 'ä¸‹æ¬¡å¤¢å¢ƒé‡‘éŒ¢ç²å–é‡åŠ å€ï¼Œä½†å¥½å¤¢æ©Ÿç‡æ¸›åŠã€‚', effect: { moneyMultiplier: 2, goodChanceMultiplier: 0.5 } }, 'peace': { name: 'å®‰ç¥è—¥æ°´', description: 'ä¸‹æ¬¡å¤¢å¢ƒå¿…å®šæˆåŠŸï¼Œä½†é‡‘éŒ¢ç²å–é‡æ¸›åŠã€‚', effect: { moneyMultiplier: 0.5, forceSuccess: true } }, 'greed': { name: 'è²ªå©ªè—¥æ°´', description: 'ä¸‹æ¬¡å¤¢å¢ƒé‡‘éŒ¢ç²å–é‡è®Šç‚ºä¸‰å€ï¼Œä½†å¿…å®šæ˜¯å£å¤¢ã€‚', effect: { moneyMultiplier: 3, forceBadDream: true } }, 'risk': { name: 'é¢¨éšªè—¥åŠ‘', description: 'ä¸‹æ¬¡å¤¢å¢ƒè‹¥æ˜¯å¥½å¤¢ï¼Œçå‹µx3ï¼›è‹¥æ˜¯å£å¤¢ï¼Œæ‡²ç½°ä¹Ÿx3ã€‚', effect: { moneyMultiplier: 3, isRisky: true } } };
    const goodDreams = [ { name: 'æ˜Ÿå…‰æ•æ‰‹', startFunction: startStarCatcher }, { name: 'è¨˜æ†¶æ˜Ÿè»Œ', startFunction: startMemoryTrail }, { name: 'å¤¢å¢ƒé‡£é­š', startFunction: startDreamFishing }, { name: 'æƒ…ç·’æ•´ç†', startFunction: startTidyEmotions }, { name: 'å¤¢å¢ƒç·¨ç¹”', startFunction: startDreamWeaving } ];
    const badDreams = [ { name: 'å¤¢é­˜æ™è„«', startFunction: startNightmareEscape }, { name: 'è¿·å®®å²”è·¯', startFunction: startMazeQTE }, { name: 'èº²é¿é™°å½±', startFunction: startDodgeShadows }, { name: 'é¬¼å£“åºŠ', startFunction: startSleepParalysis } ];
    const fortunes = [ { name: 'å¤§å‰', color: '#ff4757', tagline: 'ä»Šå¤©å°‡æ˜¯ç„¡èˆ‡å€«æ¯”çš„ä¸€å¤©ï¼', effect: () => { const bonus = 50 + 10 * pillowLevel; money += bonus; return `ç²å¾—äº† ${bonus} ğŸ’° çš„æ„å¤–ä¹‹è²¡ï¼`; } }, { name: 'ä¸­å‰', color: '#ffa502', tagline: 'å¥½é‹æ­£åœ¨å‘ä½ æ‹›æ‰‹ã€‚', effect: () => { tempGoodDreamChanceBonus = 10; return `ä¸‹æ¬¡å…¥ç¡çš„å¥½å¤¢æ©Ÿç‡æš«æ™‚æå‡10%ï¼`; } }, { name: 'å°å‰', color: '#2ed573', tagline: 'å¾®å°çš„å¹¸é‹ï¼Œä¹Ÿèƒ½å¸¶ä¾†å¿«æ¨‚ã€‚', effect: () => { const bonus = 20 + 5 * pillowLevel; money += bonus; return `æ’¿åˆ°äº† ${bonus} ğŸ’°ï¼`; } }, { name: 'å‡¶', color: '#5352ed', tagline: 'çƒé›²ç± ç½©...çœ‹ä¾†è¦å°å¿ƒè¡Œäº‹ã€‚', effect: () => { const loss = 15 * bedLevel; money = Math.max(0, money - loss); return `ä¸å°å¿ƒéºå¤±äº† ${loss} ğŸ’°...`; } }, { name: 'å¤§å‡¶', color: '#1e272e', tagline: 'è«¸äº‹ä¸é †ï¼Œç ´è²¡ä¹‹ç›¸ï¼', effect: () => { money = Math.floor(money * 0.8); return `é­é‡è¿é ­ç—›æ“Šï¼Œæå¤±äº†20%çš„è²¡ç”¢ï¼`; } } ];
    const randomMainEvents = [ { name: 'Meteor Shower', start: startMeteorShower }, { name: 'Dream Merchant', start: startDreamMerchant } ];
    const merchantPotions = [ { id: 'power', cost: 100 }, { id: 'peace', cost: 120 }, { id: 'greed', cost: 200 }, { id: 'risk', cost: 80 } ];
    const storyData = { 1: { title: "ç¬¬ä¸€å¤œ", text: "é€™æ˜¯ä¸€å€‹å¥‡æ€ªçš„å¤¢...æ„Ÿè¦ºæ—¢ç†Ÿæ‚‰åˆé™Œç”Ÿã€‚" }, 5: { title: "ç¬¬äº”å¤œ", text: "å¶çˆ¾ï¼Œä½ æœƒåœ¨å£å¤¢çš„é‚Šç·£ç¥è¦‹ä¸€äº›é™°å½±ï¼Œå®ƒå€‘ä¼¼ä¹åœ¨ä½èªã€‚" }, 10: { title: "ç¬¬åå¤œçš„è¨˜æ†¶", text: "ä½ æ„Ÿè¦ºåºŠé‹ªæŸ”è»Ÿå¾—ä¸å¯æ€è­°ã€‚å¤¢ä¸­çš„é‡‘éŒ¢ä¼¼ä¹ä¹Ÿè®Šå¾—æ›´ã€çœŸå¯¦ã€äº†ã€‚ä¸€çµ²æ¨¡ç³Šçš„è¨˜æ†¶é–ƒéï¼šä¸€é–“æ˜äº®çš„æˆ¿é–“ï¼Œçª—å¤–æ˜¯ç¶ è‰²çš„...æ˜¯ä»€éº¼ï¼Ÿ" }, 15: { title: "ç¬¬åäº”å¤œ", text: "ä½ é–‹å§‹ç¿’æ…£åœ¨å¤¢ä¸­é†’ä¾†ï¼Œå‡ç´šï¼Œç„¶å¾Œå†æ¬¡å…¥ç¡ã€‚é€™å½·å½¿æˆäº†ä¸€ç¨®å„€å¼ã€‚" }, 20: { title: "ç¬¬äºŒåå¤œçš„ä½èª", text: "ä½ åœ¨å£å¤¢ä¸­è½è¦‹äº†æ›´æ¸…æ™°çš„è€³èªï¼šã€...é‚„ä¸å¤ ...ã€ã€‚æ˜¯èª°åœ¨èªªè©±ï¼Ÿ" }, 25: { title: "ç¬¬äºŒåäº”å¤œ", text: "å¤¢å¢ƒå•†äººæ˜¯å€‹å¥‡æ€ªçš„å‚¢ä¼™ã€‚ä»–çš„è—¥æ°´æ•ˆæœå¼·å¤§ï¼Œä½†ç¸½æ„Ÿè¦ºä»–å°ä½ çš„è™•å¢ƒç­è‹¥æŒ‡æŒã€‚" }, 30: { title: "ç¬¬ä¸‰åå¤œçš„æ°£å‘³", text: "å¤¢å¢ƒçš„è‰²å½©æ¯”å¹³æ™‚æ›´é®®è±”äº†ã€‚ä½ ç¬¬ä¸€æ¬¡åœ¨å¤¢è£¡ï¼Œèåˆ°äº†å¯§ç¥è–°é¦™çš„å‘³é“...é€™å‘³é“è®“ä½ å¹¾ä¹æƒ³èµ·äº†æŸå€‹æº«æš–çš„åˆå¾Œã€‚" }, 38: { title: "ç¬¬ä¸‰åå…«å¤œ", text: "æœ‰é‚£éº¼ä¸€ç¬é–“ï¼Œä½ çœ‹è‘—æ•é ­ï¼Œè¦ºå¾—å®ƒæ‡‰è©²æ˜¯å¦ä¸€ç¨®é¡è‰²ã€‚ä½†ä½ å¾ˆå¿«å°±å¿˜äº†é‚£æ˜¯ä»€éº¼é¡è‰²ã€‚" }, 40: { title: "ç¬¬å››åå¤œçš„ç¥è¦‹", text: "ä½ ç¥è¦‹ä¸€å€‹ç¥ç§˜çš„å½±å­ï¼Œå®ƒä¼¼ä¹å°±æ˜¯é‚£ä½å¶çˆ¾å‡ºç¾çš„å•†äººã€‚ä»–å°ä½ é»äº†é»é ­ï¼Œä¾¿æ¶ˆå¤±åœ¨è¿·éœ§ä¸­ã€‚ä»–ä¸æ˜¯æ•µäººå—ï¼Ÿ" }, 46: { title: "ç¬¬å››åå…­å¤œ", text: "æµæ˜Ÿé›¨åŠƒéå¤©éš›æ™‚ï¼Œä½ è¨±äº†ä¸€å€‹é¡˜ï¼šã€æˆ‘æƒ³å›å®¶ã€ã€‚ä½†ä½ ç”šè‡³ä¸ç¢ºå®šå®¶åœ¨å“ªè£¡ã€‚" }, 50: { title: "ç¬¬äº”åå¤œçš„ç¢ç‰‡", text: "åŠå¤¢åŠé†’ä¹‹é–“ï¼Œä½ æŠ“ä½äº†ä¸€äº›è¨˜æ†¶ç¢ç‰‡ï¼šç¬‘è²ã€é™½å…‰ã€é‚„æœ‰ä¸€å€‹æ¨¡ç³Šçš„äººå½±ã€‚ä½†å®ƒå€‘åƒæŒ‡é–“çš„æ²™ä¸€æ¨£æºœèµ°ã€‚å¿ƒè£¡ä¸€é™£åˆºç—›ã€‚" }, 58: { title: "ç¬¬äº”åå…«å¤œ", text: "æ•å¤¢ç¶²ä¸åƒ…èƒ½æ“‹ä½é‡‘éŒ¢çš„æµå¤±ï¼Œä¼¼ä¹ä¹Ÿèƒ½éæ¿¾æ‰ä¸€äº›æœ€æ·±æ²‰çš„ææ‡¼ã€‚" }, 60: { title: "ç¬¬å…­åå¤œçš„æ·šç ", text: "ä½ ç™¼ç¾æ•å¤¢ç¶²ä¸Šæ›è‘—ä¸€é¡†å°å°çš„ã€é–ƒå…‰çš„éœ²ç ã€‚ä½ è§¸ç¢°å®ƒï¼Œä¸€è‚¡æ‚²å‚·çš„æƒ…ç·’æ¹§ä¸Šå¿ƒé ­ã€‚é€™ä¸æ˜¯ä½ çš„...å°å§ï¼Ÿ" }, 67: { title: "ç¬¬å…­åä¸ƒå¤œ", text: "ä½ é–‹å§‹äº«å—æƒ…ç·’æ•´ç†çš„éç¨‹ï¼Œå°‡æ··äº‚çš„æ„Ÿè¦ºä¸€ä¸€æ­¸ä½ï¼Œä¼¼ä¹ä¹Ÿåœ¨æ•´ç†è‡ªå·±æ··äº‚çš„è¨˜æ†¶ã€‚" }, 70: { title: "ç¬¬ä¸ƒåå¤œçš„é¼é—Š", text: "å¤¢ä¸­çš„ä¸–ç•Œè®Šå¾—å»£é—Šç„¡é‚Šï¼Œä½ æ„Ÿè¦ºè‡ªå·±å½·å½¿èƒ½èµ°åˆ°ä»»ä½•åœ°æ–¹...åªè¦ä½ é‚„æƒ³ç¹¼çºŒåšå¤¢ã€‚ä½†...ä½ çœŸçš„æƒ³å—ï¼Ÿ" }, 75: { title: "ç¬¬ä¸ƒåäº”å¤œ", text: "ä½ é–‹å§‹æ‡·ç–‘ï¼Œé€™äº›å¥½å¤¢å’Œå£å¤¢ï¼Œä¹Ÿè¨±éƒ½æºæ–¼ä½ è‡ªå·±ã€‚" }, 80: { title: "ç¬¬å…«åå¤œçš„å…‰èŠ’", text: "ä½ å°å¤¢å¢ƒçš„æŒæ§åŠ›è¶Šä¾†è¶Šå¼·ã€‚åœ¨ä¸€æ¬¡å£å¤¢ä¸­ï¼Œä½ æ†‘è—‰è‡ªå·±çš„æ„å¿—é»äº®äº†ä¸€ç›ç‡ˆï¼Œé™°å½±çŸ­æš«åœ°é€€å»äº†ã€‚ä½ ç¬¬ä¸€æ¬¡æ„Ÿè¦ºåˆ°åŠ›é‡ã€‚" }, 88: { title: "ç¬¬å…«åå…«å¤œ", text: "ã€é†’ä¾†ã€é€™å€‹è©ï¼Œç¾åœ¨è½èµ·ä¾†æ—¢å……æ»¿å¸Œæœ›ï¼Œåˆè®“äººç•æ‡¼ã€‚" }, 90: { title: "ç¬¬ä¹åå¤œçš„å¹³éœ", text: "ä¸€ç¨®å¥‡ç‰¹çš„å¹³éœæ„Ÿç± ç½©è‘—ä½ ã€‚ä½ ä¸å†å®³æ€•å£å¤¢ï¼Œä¹Ÿä¸å†è²ªæˆ€å¥½å¤¢ã€‚ä½ å¥½åƒ...æº–å‚™å¥½äº†ã€‚" }, 95: { title: "ç¬¬ä¹åäº”å¤œ", text: "ä½ æœ€å¾Œä¸€æ¬¡å‡ç´šäº†ä½ çš„åºŠã€‚å®ƒç„¡æ¯”èˆ’é©ï¼Œä½†ä½ çŸ¥é“ä½ ä¸æœƒå†éœ€è¦å®ƒäº†ã€‚" }, 99: { title: "ç¬¬ä¹åä¹å¤œ", text: "æœ€å¾Œä¸€å¤œã€‚ä½ å¹³éœåœ°èººä¸‹ï¼Œä½ çŸ¥é“ï¼Œé€™æ¬¡å…¥ç¡å°‡æœƒæ˜¯æœ€å¾Œä¸€æ¬¡ã€‚" } };
    const endingContent = "ç¬¬ä¸€ç™¾å¤œï¼Œä½ çœé–‹äº†é›™çœ¼ã€‚æ²’æœ‰å¥½å¤¢ï¼Œä¹Ÿæ²’æœ‰å£å¤¢ã€‚å‘¨é­ä¸€ç‰‡è™›ç„¡ï¼Œåªæœ‰ä¸€æ‰‡æ•£ç™¼è‘—å¾®å…‰ã€ç”±ä½ æ‰€æœ‰å¤¢å¢ƒç¢ç‰‡æ§‹æˆçš„é–€æ‰‰ã€‚ä½ å¹³éœåœ°èµ°ä¸Šå‰ï¼Œè¼•è¼•æ¨é–‹ã€‚é–€å¾Œæ˜¯æº«æš–çš„æ™¨å…‰ï¼Œä»¥åŠä¸€å€‹ä½ å¹¾ä¹éºå¿˜çš„ã€å¶„æ–°çš„é–‹å§‹ã€‚";
    
    // --- 2. å…ƒç´ è®Šæ•¸å®£å‘Š ---
    let gameContainer, dayCountEl, moneyEl, goodDreamChanceEl, gameLogEl, sleepButton, bedLevelEl, pillowLevelEl, dreamCatcherLevelEl, incenseLevelEl, bedUpgradeCostEl, pillowUpgradeCostEl, dreamCatcherUpgradeCostEl, incenseUpgradeCostEl, upgradeBedButton, upgradePillowButton, upgradeDreamCatcherButton, upgradeIncenseButton, minigameModal, minigameTitle, minigameInstruction, minigameInfoBar, minigameArea, minigameResultEl, eventModal, eventResultEl, cardContainer, goodDreamItemCostEl, badDreamItemCostEl, buyGoodDreamItemButton, buyBadDreamItemButton, merchantModal, merchantTimerEl, merchantItemsEl, potionEffectStatusEl, settingsButton, settingsModal, deleteSaveButton, settingsCloseButton, storyModal, storyModalTitle, storyModalText, storyModalCloseButton, endingModal, endingText, endingResetButton, endingContinueButton, backpackButton, backpackModal, backpackItemsEl, backpackCloseButton, mobileControlsContainer;

    // --- 3. æ ¸å¿ƒåŠŸèƒ½å‡½å¼ ---
    function logMessage(message, isLoad = false) { const p = document.createElement('p'); p.innerHTML = message; gameLogEl.appendChild(p); gameLogEl.scrollTop = gameLogEl.scrollHeight; if (!isLoad) { gameLogHTML = gameLogEl.innerHTML; saveGame(); } }
    
    function updateStatsUI() { 
        if(!dayCountEl) return;
        dayCountEl.textContent = dayCount;
        moneyEl.textContent = money; 
        goodDreamChanceEl.innerHTML = `${baseGoodDreamChance}% ${tempGoodDreamChanceBonus > 0 ? `<span style="color:var(--good-color)">(+${tempGoodDreamChanceBonus}%)</span>` : ''}`;

        bedLevelEl.textContent = bedLevel; pillowLevelEl.textContent = pillowLevel; dreamCatcherLevelEl.textContent = dreamCatcherLevel; incenseLevelEl.textContent = incenseLevel;
        bedUpgradeCostEl.textContent = bedUpgradeCost; pillowUpgradeCostEl.textContent = pillowUpgradeCost; dreamCatcherUpgradeCostEl.textContent = dreamCatcherUpgradeCost; incenseUpgradeCostEl.textContent = incenseUpgradeCost;
        
        const buttonsDisabled = minigameActive || eventActive || mainScreenEventActive || storyModalActive || endingActive || settingsModalActive || backpackModalActive;
        
        sleepButton.disabled = buttonsDisabled; 
        backpackButton.disabled = buttonsDisabled;
        upgradeBedButton.disabled = money < bedUpgradeCost || buttonsDisabled || baseGoodDreamChance >= 95;
        upgradePillowButton.disabled = money < pillowUpgradeCost || buttonsDisabled;
        upgradeDreamCatcherButton.disabled = money < dreamCatcherUpgradeCost || buttonsDisabled;
        upgradeIncenseButton.disabled = money < incenseUpgradeCost || buttonsDisabled;
        buyGoodDreamItemButton.disabled = money < goodDreamItemCost || buttonsDisabled;
        buyBadDreamItemButton.disabled = money < badDreamItemCost || buttonsDisabled;
        
        let effectText = "";
        if (effectNextGoodDream) effectText = "æ•ˆæœ: ä¸‹æ¬¡å¿…å®šå¥½å¤¢";
        else if (effectNextBadDream) effectText = "æ•ˆæœ: ä¸‹æ¬¡å¿…å®šå£å¤¢";
        else if (activePotion) effectText = `è—¥æ°´æ•ˆæœ: ${itemsData[activePotion.id].name}`;
        potionEffectStatusEl.textContent = effectText;
    }
    
    function goToSleep() {
        if (dayCount === 0 && storyData[1]) { logMessage(`<i>${storyData[1].text}</i>`); }
        dayCount++;
        logMessage(`--- ç¬¬ ${dayCount} å¤© ---`);
        
        let isGoodDream;
        if (effectNextGoodDream) { isGoodDream = true; effectNextGoodDream = false; logMessage("ğŸ€ ä½ ä½¿ç”¨äº†å¹¸é‹å››è‘‰è‰..."); } 
        else if (effectNextBadDream) { isGoodDream = false; effectNextBadDream = false; logMessage("ğŸ ä½ ä½¿ç”¨äº†è©›å’’å¨ƒå¨ƒ..."); } 
        else if (activePotion && itemsData[activePotion.id].effect.forceBadDream) { isGoodDream = false; logMessage(`ğŸ§ª ${itemsData[activePotion.id].name} çš„æ•ˆæœç™¼ä½œäº†...`); } 
        else { 
            let finalChance = baseGoodDreamChance + tempGoodDreamChanceBonus;
            finalChance *= (activePotion ? (itemsData[activePotion.id].effect.goodChanceMultiplier || 1) : 1);
            isGoodDream = Math.random() * 100 < finalChance; 
        }
        tempGoodDreamChanceBonus = 0;
        
        minigameActive = true; 
        saveGameAndUpdateUI();
        logMessage("ä½ ç·©ç·©é–‰ä¸Šçœ¼ç›ï¼Œé€²å…¥äº†å¤¢é„‰..."); 

        setTimeout(() => { 
            const dreamPool = isGoodDream ? goodDreams : badDreams; 
            const selectedDream = dreamPool[Math.floor(Math.random() * dreamPool.length)]; 
            selectedDream.startFunction(); 
        }, 1500); 
    }

    function checkPostSleepEvents() {
        hideMinigame();
        if (dayCount >= 100) { setTimeout(showEnding, 500); } 
        else if (storyData[dayCount]) { setTimeout(() => showStory(dayCount), 500); }
    }
    
    function showEndScreen(resultText, logText, success) { 
        if (!minigameActive) return;
        if (activePotion && itemsData[activePotion.id].effect.forceSuccess) { success = true; resultText += " (è—¥æ°´æ•ˆæœ)"; }
        
        minigameActive = false; 
        clearTimersAndListeners(); 
        minigameArea.style.pointerEvents = 'none'; 
        minigameResultEl.textContent = resultText; 
        minigameResultEl.style.color = success === false ? 'var(--bad-color)' : success === true ? 'var(--good-color)' : 'var(--neutral-color)'; 
        if (logText) logMessage(logText); 
        
        if(activePotion) { logMessage(`ğŸ§ª ${itemsData[activePotion.id].name} çš„æ•ˆæœæ¶ˆå¤±äº†ã€‚`); activePotion = null; }
        
        saveGame();
        
        const EVENT_CHANCE = 0.3; 
        if (Math.random() < EVENT_CHANCE && dayCount < 100) { setTimeout(() => startFortuneEvent(), 2000); } 
        else { setTimeout(checkPostSleepEvents, 3000); } 
    }
    
    function hideMinigame() { 
        gameContainer.classList.remove('frozen'); 
        minigameModal.classList.add('hidden'); 
        if (!eventActive && !storyModalActive && !endingActive) { minigameActive = false; saveGameAndUpdateUI(); } 
    }
    
    function flipCard(clickedCard, chosenFortune) { 
        document.querySelectorAll('.card').forEach(c => c.onclick = null); clickedCard.classList.add('is-flipped'); const effectMessage = chosenFortune.effect(); logMessage(`ã€é‹å‹¢ï¼š${chosenFortune.name}ã€‘${chosenFortune.tagline} ${effectMessage}`); eventResultEl.textContent = effectMessage; saveGameAndUpdateUI();
        setTimeout(() => { document.querySelectorAll('.card:not(.is-flipped)').forEach(otherCard => { otherCard.classList.add('is-flipped'); }); }, 1000); 
        setTimeout(() => { eventModal.classList.add('hidden'); eventActive = false; checkPostSleepEvents(); }, 4000); 
    }

    function calculateEarnings(baseAmount, isLoss = false) {
        let multiplier = 1;
        if (activePotion) {
            if (itemsData[activePotion.id].effect.isRisky) { multiplier = 3; } 
            else if (!isLoss) { multiplier = itemsData[activePotion.id].effect.moneyMultiplier || 1; }
        }
        let finalAmount = baseAmount * multiplier;
        if (isLoss) { const lossReduction = 1 - (dreamCatcherLevel - 1) * 0.1; finalAmount *= lossReduction; }
        return Math.round(finalAmount);
    }
    
    function upgradeBed() { if (money >= bedUpgradeCost) { money -= bedUpgradeCost; bedLevel++; baseGoodDreamChance = Math.min(95, baseGoodDreamChance + 5); bedUpgradeCost = Math.floor(bedUpgradeCost * 1.6); logMessage(`ğŸ› ï¸ åºŠå‡ç´šäº†ï¼ç­‰ç´š ${bedLevel}ï¼ŒåŸºç¤å¥½å¤¢æ©Ÿç‡æå‡è‡³ ${baseGoodDreamChance}%ã€‚`); saveGameAndUpdateUI(); } }
    function upgradePillow() { if (money >= pillowUpgradeCost) { money -= pillowUpgradeCost; pillowLevel++; pillowUpgradeCost = Math.floor(pillowUpgradeCost * 1.7); logMessage(`ğŸ› ï¸ æ•é ­å‡ç´šäº†ï¼ç­‰ç´š ${pillowLevel}ï¼Œé‡‘éŒ¢ç²å–é‡æå‡ã€‚`); saveGameAndUpdateUI(); } }
    function upgradeDreamCatcher() { if (money >= dreamCatcherUpgradeCost) { money -= dreamCatcherUpgradeCost; dreamCatcherLevel++; dreamCatcherUpgradeCost = Math.floor(dreamCatcherUpgradeCost * 1.8); logMessage(`ğŸ› ï¸ æ•å¤¢ç¶²å‡ç´šäº†ï¼ç­‰ç´š ${dreamCatcherLevel}ï¼Œèƒ½æŠµç¦¦æ›´å¤šå£å¤¢æå¤±ã€‚`); saveGameAndUpdateUI(); } }
    function upgradeIncense() { if (money >= incenseUpgradeCost) { money -= incenseUpgradeCost; incenseLevel++; incenseUpgradeCost = Math.floor(incenseUpgradeCost * 1.75); logMessage(`ğŸ› ï¸ å¯§ç¥è–°é¦™å‡ç´šäº†ï¼ç­‰ç´š ${incenseLevel}ï¼Œå¤¢å¢ƒè®Šå¾—æ›´å®‰ç©©ã€‚`); saveGameAndUpdateUI(); } }
    function startFortuneEvent() { eventActive = true; updateStatsUI(); eventModal.classList.remove('hidden'); cardContainer.innerHTML = ''; eventResultEl.textContent = ''; const shuffledFortunes = [...fortunes].sort(() => 0.5 - Math.random()); const selectedFortunes = shuffledFortunes.slice(0, 3); selectedFortunes.forEach(fortune => { const card = document.createElement('div'); card.className = 'card'; const cardInner = document.createElement('div'); cardInner.className = 'card-inner'; const cardBack = document.createElement('div'); cardBack.className = 'card-face card-back'; cardBack.textContent = 'â“'; const cardFront = document.createElement('div'); cardFront.className = 'card-face card-front'; cardFront.innerHTML = `<div class="fortune-name" style="color:${fortune.color};">${fortune.name}</div><div class="fortune-tagline">${fortune.tagline}</div>`; cardInner.appendChild(cardBack); cardInner.appendChild(cardFront); card.appendChild(cardInner); card.onclick = () => flipCard(card, fortune); cardContainer.appendChild(card); }); }
    
    // --- 4. å­˜æª”/å•†åº—/èƒŒåŒ…/åŠ‡æƒ…ç³»çµ± ---
    function saveGame() {
        const gameState = { dayCount, money, baseGoodDreamChance, bedLevel, pillowLevel, dreamCatcherLevel, incenseLevel, bedUpgradeCost, pillowUpgradeCost, dreamCatcherUpgradeCost, incenseUpgradeCost, inventory, gameLogHTML, effectNextGoodDream, effectNextBadDream, activePotion };
        localStorage.setItem('dreamGameSaveData', JSON.stringify(gameState));
    }

    function loadGame() {
        const savedData = localStorage.getItem('dreamGameSaveData');
        if (savedData) {
            const gameState = JSON.parse(savedData);
            dayCount = gameState.dayCount || 0; money = gameState.money || 0; baseGoodDreamChance = gameState.baseGoodDreamChance || 50; bedLevel = gameState.bedLevel || 1; pillowLevel = gameState.pillowLevel || 1; dreamCatcherLevel = gameState.dreamCatcherLevel || 1; incenseLevel = gameState.incenseLevel || 1; bedUpgradeCost = gameState.bedUpgradeCost || 50; pillowUpgradeCost = gameState.pillowUpgradeCost || 70; dreamCatcherUpgradeCost = gameState.dreamCatcherUpgradeCost || 100; incenseUpgradeCost = gameState.incenseUpgradeCost || 120; inventory = gameState.inventory || {}; gameLogHTML = gameState.gameLogHTML || "æ­¡è¿ä¾†åˆ°å¤¢å¢ƒéŠæˆ²ï¼ä»Šæ™šæœƒæ˜¯ä»€éº¼å¤¢å‘¢ï¼Ÿ"; effectNextGoodDream = gameState.effectNextGoodDream || false; effectNextBadDream = gameState.effectNextBadDream || false; activePotion = gameState.activePotion || null;
            logMessage("ğŸ’¾ è®€å–å­˜æª”æˆåŠŸï¼æ­¡è¿å›ä¾†ã€‚", true);
        } else {
            dayCount = 0; money = 0; baseGoodDreamChance = 50; bedLevel = 1; pillowLevel = 1; dreamCatcherLevel = 1; incenseLevel = 1; bedUpgradeCost = 50; pillowUpgradeCost = 70; dreamCatcherUpgradeCost = 100; incenseUpgradeCost = 120; inventory = {}; gameLogHTML = ""; effectNextGoodDream = false; effectNextBadDream = false; activePotion = null;
            logMessage("æ­¡è¿ä¾†åˆ°å¤¢å¢ƒéŠæˆ²ï¼ä»Šæ™šæœƒæ˜¯ä»€éº¼å¤¢å‘¢ï¼Ÿ", true);
        }
        tempGoodDreamChanceBonus = 0;
        gameLogEl.innerHTML = gameLogHTML;
        gameLogEl.scrollTop = gameLogEl.scrollHeight;
    }
    
    function saveGameAndUpdateUI() { saveGame(); updateStatsUI(); }
    function deleteSaveAndReset() { deleteSaveButton.disabled = true; if (confirm("è­¦å‘Šï¼šæ­¤å‹•ä½œå°‡æœƒæ°¸ä¹…åˆªé™¤æ‚¨æ‰€æœ‰çš„éŠæˆ²é€²åº¦ï¼Œç¢ºå®šè¦é‡ç½®å—ï¼Ÿ")) { localStorage.removeItem('dreamGameSaveData'); location.reload(); } else { deleteSaveButton.disabled = false; } }
    function showStory(day) { storyModalActive = true; gameContainer.classList.add('frozen'); const story = storyData[day]; storyModalTitle.textContent = story.title; storyModalText.textContent = story.text; storyModal.classList.remove('hidden'); logMessage(`<strong>--- ${story.title} ---</strong><br><i>${story.text}</i>`); updateStatsUI(); }
    function showEnding() { endingActive = true; gameContainer.classList.add('frozen'); endingModal.classList.remove('hidden'); logMessage(`<strong>--- ç¬¬ä¸€ç¯‡ç« ãƒ»å®Œ ---</strong>`); updateStatsUI(); }

    function buyItem(itemId, cost) {
        if (money >= cost) {
            money -= cost;
            inventory[itemId] = (inventory[itemId] || 0) + 1;
            logMessage(`ğŸ›ï¸ ä½ è³¼è²·äº† ${itemsData[itemId].name}ï¼`);
            saveGameAndUpdateUI();
        }
    }

    function openBackpack() { backpackModalActive = true; renderBackpack(); backpackModal.classList.remove('hidden'); updateStatsUI(); }
    function closeBackpack() { backpackModalActive = false; backpackModal.classList.add('hidden'); updateStatsUI(); }
    function renderBackpack() {
        backpackItemsEl.innerHTML = '';
        if (Object.keys(inventory).every(k => !inventory[k])) { backpackItemsEl.innerHTML = '<p>ä½ çš„èƒŒåŒ…ç©ºç„¡ä¸€ç‰©ã€‚</p>'; return; }
        for(const itemId in inventory) {
            if (inventory[itemId] > 0) {
                const item = itemsData[itemId];
                const itemDiv = document.createElement('div');
                itemDiv.className = 'upgrade-item';
                itemDiv.innerHTML = `<div><p><strong>${item.name}</strong> (æŒæœ‰: ${inventory[itemId]})</p><p>${item.description}</p></div><button data-item-id="${itemId}">ä½¿ç”¨</button>`;
                backpackItemsEl.appendChild(itemDiv);
            }
        }
    }
    function useItem(itemId) {
        const hasActiveEffect = effectNextGoodDream || effectNextBadDream || activePotion;
        if (hasActiveEffect) { logMessage("âŒ ä½ å·²ç¶“æœ‰ä¸€å€‹ç”Ÿæ•ˆä¸­çš„ç‰©å“äº†ï¼"); return; }
        inventory[itemId]--;
        if (inventory[itemId] <= 0) delete inventory[itemId];
        switch(itemId) {
            case 'luckyClover': effectNextGoodDream = true; break;
            case 'cursedDoll': effectNextBadDream = true; break;
            default: const potionData = merchantPotions.find(p => p.id === itemId); if(potionData) activePotion = potionData; break;
        }
        logMessage(`ä½ ä½¿ç”¨äº† ${itemsData[itemId].name}ï¼`);
        closeBackpack();
        saveGameAndUpdateUI();
    }
    
    // --- 5. äº‹ä»¶èˆ‡å°éŠæˆ²é‚è¼¯ ---
    function triggerRandomEvent() { if (minigameActive || eventActive || mainScreenEventActive || storyModalActive || endingActive || backpackModalActive) return; const CHANCE = 0.25; if (Math.random() < CHANCE) { const selectedEvent = randomMainEvents[Math.floor(Math.random() * randomMainEvents.length)]; selectedEvent.start(); } }
    function startMeteorShower() { mainScreenEventActive = true; document.body.style.overflow = 'hidden'; saveGameAndUpdateUI(); logMessage("ğŸŒ  å¤©ç©ºé–‹å§‹é™ä¸‹æµæ˜Ÿé›¨ï¼å¿«é»æ“Šå®ƒå€‘ï¼"); let meteorsCaught = 0; const duration = 10000; const spawner = setInterval(() => { const meteor = document.createElement('div'); meteor.textContent = 'â˜„ï¸'; meteor.className = 'meteor'; meteor.style.left = `${Math.random() * 100}vw`; meteor.style.top = `-50px`; meteor.style.animation = `fall-meteor ${2 + Math.random() * 2}s linear`; meteor.onclick = () => { meteorsCaught++; const reward = Math.ceil(1 + pillowLevel * 0.5); money += reward; updateStatsUI(); meteor.classList.add('popped'); meteor.onclick = null; setTimeout(() => meteor.remove(), 300); }; document.body.appendChild(meteor); setTimeout(() => { if(meteor) meteor.remove() }, 4000); }, 300); setTimeout(() => { clearInterval(spawner); mainScreenEventActive = false; document.body.style.overflow = 'auto'; logMessage(`ğŸŒ  æµæ˜Ÿé›¨çµæŸäº†ï¼Œä½ æŠ“åˆ°äº† ${meteorsCaught} é¡†æµæ˜Ÿï¼`); saveGameAndUpdateUI(); }, duration); }
    function startDreamMerchant() { mainScreenEventActive = true; saveGameAndUpdateUI(); merchantModal.classList.remove('hidden'); logMessage("ğŸ­ ä¸€ä½ç¥ç§˜çš„å•†äººå‡ºç¾åœ¨ä½ çš„å¤¢å¢ƒé‚Šç·£..."); let timeLeft = 20; merchantTimerEl.textContent = timeLeft; merchantItemsEl.innerHTML = ''; const shuffledPotions = [...merchantPotions].sort(() => 0.5 - Math.random()); const itemsForSale = shuffledPotions.slice(0, 2); itemsForSale.forEach(potion => { const item = itemsData[potion.id]; const itemDiv = document.createElement('div'); itemDiv.className = 'upgrade-item'; itemDiv.innerHTML = `<div><p><strong>${item.name}</strong></p><p>${item.description}</p><p>åƒ¹æ ¼: ${potion.cost} ğŸ’°</p></div><button data-item-id="${potion.id}" data-cost="${potion.cost}">è³¼è²·</button>`; merchantItemsEl.appendChild(itemDiv); }); const buttons = merchantItemsEl.querySelectorAll('button'); buttons.forEach(b => { b.disabled = money < b.dataset.cost; b.onclick = (e) => { const itemId = e.target.dataset.itemId; const cost = parseInt(e.target.dataset.cost); buyItem(itemId, cost); buttons.forEach(btn => btn.disabled = money < btn.dataset.cost); }; }); const timer = setInterval(() => { timeLeft--; merchantTimerEl.textContent = timeLeft; if (timeLeft <= 0) { closeMerchant(timer); } }, 1000); const closeMerchant = (timerToClear = timer) => { clearInterval(timerToClear); merchantModal.classList.add('hidden'); mainScreenEventActive = false; logMessage("å•†äººç¥ç§˜åœ°æ¶ˆå¤±äº†..."); saveGameAndUpdateUI(); } }
    function clearTimersAndListeners() {
        clearInterval(gameInterval); clearTimeout(gameTimeout);
        if (keydownHandler) document.removeEventListener('keydown', keydownHandler);
        if (keyupHandler) document.removeEventListener('keyup', keyupHandler);
        if (mousemoveHandler) minigameArea.removeEventListener('mousemove', mousemoveHandler);
        if (touchMoveHandler) minigameArea.removeEventListener('touchmove', touchMoveHandler);
        const holdButton = document.getElementById('mobile-hold-button');
        if (holdButton && touchStartHandler) holdButton.removeEventListener('touchstart', touchStartHandler);
        if (holdButton && touchEndHandler) holdButton.removeEventListener('touchend', touchEndHandler);
        keydownHandler = keyupHandler = mousemoveHandler = touchMoveHandler = touchStartHandler = touchEndHandler = gameInterval = gameTimeout = null;
    }
    function showMinigame() { gameContainer.classList.add('frozen'); minigameModal.classList.remove('hidden'); minigameResultEl.innerHTML = ''; minigameInfoBar.innerHTML = ''; minigameArea.innerHTML = ''; minigameInstruction.textContent = ''; mobileControlsContainer.innerHTML = ''; mobileControlsContainer.classList.remove('visible'); minigameArea.style.pointerEvents = 'auto'; }
    function startStarCatcher() { let score = 0; let duration = 7 + (incenseLevel - 1); showMinigame(); minigameTitle.textContent = "âœ¨ æ˜Ÿå…‰æ•æ‰‹ âœ¨"; minigameInstruction.textContent = "åœ¨æ™‚é–“å…§ç›¡å¯èƒ½é»æ“Šå‡ºç¾çš„æ˜Ÿæ˜Ÿï¼"; minigameInfoBar.innerHTML = `<span>æ™‚é–“: <span id="timer">${duration}</span>s</span> <span>åˆ†æ•¸: <span id="score">0</span></span>`; const timerEl = document.getElementById('timer'); const scoreEl = document.getElementById('score'); const starSpawner = setInterval(() => { if (!minigameActive) { clearInterval(starSpawner); return; } const star = document.createElement('div'); star.textContent = 'â­'; star.className = 'star'; star.style.top = `${Math.random() * 85}%`; star.style.left = `${Math.random() * 90}%`; star.onclick = () => { if(!minigameActive) return; score++; scoreEl.textContent = score; star.onclick = null; star.classList.add('popped'); setTimeout(() => star.remove(), 300); }; minigameArea.appendChild(star); }, 500); gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); clearInterval(starSpawner); endStarCatcher(score); } }, 1000); }
    function endStarCatcher(finalScore) { const earnings = calculateEarnings(finalScore * pillowLevel * 2); money += earnings; showEndScreen(`æŠ“åˆ°äº† ${finalScore} é¡†æ˜Ÿæ˜Ÿï¼ç²å¾— ${earnings} ğŸ’°ï¼`, `ğŸŒ™ å¥½å¤¢ä¸­æŠ“åˆ° ${finalScore} é¡†æ˜Ÿæ˜Ÿï¼Œç²å¾— ${earnings} ğŸ’°ï¼`, true); }
    function startNightmareEscape() { let clicks = 0; let duration = 4; showMinigame(); minigameTitle.textContent = "ğŸ‘» å¤¢é­˜æ™è„« ğŸ‘»"; minigameInstruction.textContent = "å¿«ï¼ç˜‹ç‹‚é»æ“ŠæŒ‰éˆ•å¾å¤¢é­˜ä¸­æ™è„«ï¼"; minigameInfoBar.innerHTML = `<span>æ™‚é–“: <span id="timer">${duration}</span>s</span> <span>é»æ“Š: <span id="score">0</span></span>`; const timerEl = document.getElementById('timer'); const scoreEl = document.getElementById('score'); minigameArea.innerHTML = `<button id="mash-button" style="width: 80%; height: 80px; font-size: 1.5em; background-color: var(--bad-color);">æ™è„«ï¼</button>`; document.getElementById('mash-button').onclick = () => { if(!minigameActive) return; clicks++; scoreEl.textContent = clicks; }; gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); endNightmareEscape(clicks); } }, 1000); }
    function endNightmareEscape(finalClicks) { const threshold = 15 + bedLevel - (incenseLevel - 1); let success = finalClicks >= threshold; if (success) { const moneyLost = calculateEarnings(20, true); money = Math.max(0, money - moneyLost); showEndScreen(`æˆåŠŸæ™è„«äº†ï¼ä½†é‚„æ˜¯æå¤±äº† ${moneyLost} ğŸ’°ã€‚`, `ğŸ‘» æˆåŠŸæ™è„«å£å¤¢ï¼Œæå¤± ${moneyLost} ğŸ’°ã€‚`, success); } else { const moneyLost = calculateEarnings(40, true); money = Math.max(0, money - moneyLost); showEndScreen(`è¢«å¤¢é­˜åå™¬äº†...æå¤±äº† ${moneyLost} ğŸ’°ï¼`, `ğŸ‘» è¢«å£å¤¢æ“Šæ•—ï¼Œæå¤± ${moneyLost} ğŸ’°ã€‚`, success); } }
    function startMemoryTrail() { let sequence = [], playerSequence = [], level = 1; showMinigame(); minigameTitle.textContent = "âœ¨ è¨˜æ†¶æ˜Ÿè»Œ âœ¨"; minigameInstruction.textContent = "è¨˜ä½æ˜Ÿæ˜Ÿé–ƒçˆçš„é †åºä¸¦ä¾åºé»æ“Šã€‚"; minigameInfoBar.innerHTML = `<span>é•·åº¦: <span id="score">1</span></span>`; const scoreEl = document.getElementById('score'); function nextLevel() { minigameArea.style.pointerEvents = 'none'; minigameArea.innerHTML = '<p style="font-size: 1.5em;">è«‹è¨˜ä½é †åº...</p>'; playerSequence = []; scoreEl.textContent = level; setTimeout(() => { if(!minigameActive && !eventActive) return; minigameArea.innerHTML = ''; let positions = []; const minDistance = 18; for (let i = 0; i < level; i++) { let pos; let validPosition = false; let attempts = 0; while (!validPosition && attempts < 100) { pos = { top: 10 + Math.random() * 75, left: 10 + Math.random() * 80 }; validPosition = true; for (const existingPos of positions) { const dist = Math.sqrt(Math.pow(pos.top - existingPos.top, 2) + Math.pow(pos.left - existingPos.left, 2)); if (dist < minDistance) { validPosition = false; break; } } attempts++; } positions.push(pos); } sequence = positions.map((pos, index) => { const star = document.createElement('div'); star.className = 'memory-star'; star.textContent = 'âœ§'; star.style.top = `${pos.top}%`; star.style.left = `${pos.left}%`; star.dataset.index = index; star.onclick = () => playerClick(star); minigameArea.appendChild(star); return star; }); setTimeout(() => minigameArea.style.pointerEvents = 'auto', level * 800); sequence.forEach((star, index) => { setTimeout(() => { star.classList.add('highlight'); setTimeout(() => star.classList.remove('highlight'), 500); }, (index + 1) * 800); }); }, 1500); } function playerClick(clickedStar) { if (playerSequence.length >= sequence.length || !minigameActive) return; const clickedIndex = parseInt(clickedStar.dataset.index); if (sequence[playerSequence.length].dataset.index != clickedIndex) { clickedStar.classList.add('wrong'); endMemoryTrail(level - 1, sequence); return; } playerSequence.push(clickedIndex); clickedStar.classList.add('highlight'); if (playerSequence.length === sequence.length) { level++; setTimeout(nextLevel, 1000); } } nextLevel(); }
    function endMemoryTrail(finalLevel, correctSequence) { if (correctSequence) { correctSequence.forEach((star, index) => { setTimeout(() => star.classList.add('correct-path'), index * 100); }); } const earnings = calculateEarnings(finalLevel * finalLevel * pillowLevel * 2); money += earnings; showEndScreen(`è¨˜æ†¶ä¸­æ–·ï¼ä½ è¨˜ä½äº† ${finalLevel} å€‹ç¯€é»ã€‚ç²å¾— ${earnings} ğŸ’°ï¼`, `ä½ åœ¨è¨˜æ†¶æ˜Ÿè»Œä¸­é”åˆ°äº†é•·åº¦ ${finalLevel}ï¼Œç²å¾— ${earnings} ğŸ’°ã€‚`, finalLevel > 0); }
    function startDreamFishing() { showMinigame(); minigameTitle.textContent = "ğŸ£ å¤¢å¢ƒé‡£é­š ğŸ£"; minigameInstruction.textContent = "åœ¨é­šæ¸¸åˆ°ä¸­é–“é‡£ç·šä¸‹æ–¹æ™‚ï¼Œé»æ“Šç•«é¢ï¼"; const fish = document.createElement('div'); fish.textContent = 'ğŸŸ'; fish.className = 'fish'; fish.style.top = `${30 + Math.random() * 50}%`; const moveDuration = 2 + Math.random() * 2; fish.style.animation = `moveFish ${moveDuration}s linear infinite alternate`; minigameArea.appendChild(fish); const style = document.createElement('style'); style.innerHTML = `@keyframes moveFish { 0% { left: 5%; transform: scaleX(1); } 49% {transform: scaleX(1);} 50% {transform: scaleX(-1);} 100% { left: 85%; transform: scaleX(-1);} }`; document.head.appendChild(style); minigameArea.onclick = () => { minigameArea.onclick = null; fish.style.animationPlayState = 'paused'; const line = document.createElement('div'); line.className = 'fishing-line'; minigameArea.appendChild(line); setTimeout(() => line.style.height = '100%', 50); setTimeout(() => { if(!minigameActive && !eventActive) return; const fishRect = fish.getBoundingClientRect(); const areaRect = minigameArea.getBoundingClientRect(); const lineX = areaRect.left + (areaRect.width / 2); try{document.head.removeChild(style);}catch(e){} const success = lineX > fishRect.left && lineX < fishRect.right; if (success) fish.classList.add('popped'); endDreamFishing(success); }, 500); }; }
    function endDreamFishing(success) { if (success) { const earnings = calculateEarnings(50 * pillowLevel); money += earnings; showEndScreen(`é‡£åˆ°äº†ï¼ä¸€æ¢é‡‘å…‰é–ƒé–ƒçš„é­šï¼ç²å¾— ${earnings} ğŸ’°ï¼`, `æˆåŠŸé‡£åˆ°å¤¢å¢ƒé‡‘é­šï¼Œç²å¾— ${earnings} ğŸ’°ã€‚`, true); } else { showEndScreen(`å“å‘€ï¼Œè®“å®ƒçµ¦æºœäº†ï¼`, `å¤¢å¢ƒé‡‘é­šé€ƒèµ°äº†ï¼Œä¸€ç„¡æ‰€ç²ã€‚`, 'neutral'); } }
    function startTidyEmotions() { let score = 0; let duration = 8 + (incenseLevel - 1); showMinigame(); minigameTitle.textContent = "ğŸ˜Š æ•´ç†æƒ…ç·’ ğŸ˜­"; minigameInstruction.textContent = "é»æ“Šç¬‘è‡‰ (ğŸ˜Š) åŠ åˆ†ï¼Œé¿é–‹å“­è‡‰ (ğŸ˜­)ï¼"; minigameInfoBar.innerHTML = `<span>æ™‚é–“: <span id="timer">${duration}</span>s</span> <span>åˆ†æ•¸: <span id="score">0</span></span>`; const timerEl = document.getElementById('timer'); const scoreEl = document.getElementById('score'); const iconSpawner = setInterval(() => { if (!minigameActive) { clearInterval(iconSpawner); return; } const isGood = Math.random() > 0.4; const icon = document.createElement('div'); icon.className = 'emotion-icon'; icon.textContent = isGood ? 'ğŸ˜Š' : 'ğŸ˜­'; icon.style.left = `${Math.random() * 90}%`; icon.style.animationDuration = `${2 + Math.random() * 2}s`; icon.onclick = () => { if(!minigameActive) return; score += isGood ? 1 : -2; scoreEl.textContent = score; icon.onclick = null; icon.classList.add('popped'); setTimeout(() => icon.remove(), 300); }; minigameArea.appendChild(icon); setTimeout(() => icon.remove(), 4000); }, 600); gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); clearInterval(iconSpawner); endTidyEmotions(score); } }, 1000); }
    function endTidyEmotions(finalScore) { const earnings = calculateEarnings(finalScore * pillowLevel * 3); if (earnings >= 0) { money += earnings; showEndScreen(`æ•´ç†å®Œç•¢ï¼å¿ƒæƒ…è®Šå¥½äº†ã€‚ç²å¾—äº† ${earnings} ğŸ’°ã€‚`, `ä½ æ•´ç†äº†æƒ…ç·’ï¼Œç²å¾— ${earnings} ğŸ’°ã€‚`, true); } else { const loss = calculateEarnings(Math.abs(finalScore * 5), true); money = Math.max(0, money - loss); showEndScreen(`æ•´ç†å¤±æ•—ï¼Œå¿ƒæƒ…æ›´äº‚äº†...æå¤±äº† ${loss} ğŸ’°ã€‚`, `æ•´ç†æƒ…ç·’å¤±æ•—ï¼Œæå¤± ${loss} ğŸ’°ã€‚`, false); } }
    function startMazeQTE() { showMinigame(); minigameTitle.textContent = "ğŸ‘» è¿·å®®å²”è·¯ ğŸ‘»"; minigameInstruction.textContent = "å¿«ï¼æŒ‰ä¸‹å°æ‡‰çš„æ–¹å‘éµï¼"; minigameArea.style.display = 'flex'; minigameArea.style.flexDirection = 'column'; minigameArea.style.justifyContent = 'center'; minigameArea.innerHTML = `<div id="qte-arrow" style="font-size: 6em; color: yellow; text-shadow: 0 0 10px black;"></div><div id="qte-timer-bar-container"><div id="qte-timer-bar"></div></div>`; const qteArrow = document.getElementById('qte-arrow'); const timerBar = document.getElementById('qte-timer-bar'); const arrows = { 'ArrowUp': 'â¬†ï¸', 'ArrowDown': 'â¬‡ï¸', 'ArrowLeft': 'â¬…ï¸', 'ArrowRight': 'â¡ï¸' }; const keys = Object.keys(arrows); const correctKey = keys[Math.floor(Math.random() * keys.length)]; qteArrow.textContent = arrows[correctKey]; setTimeout(() => { timerBar.style.width = '0%'; }, 100); gameTimeout = setTimeout(() => endMazeQTE(false), 2000 + (incenseLevel * 100)); keydownHandler = (e) => { if (keys.includes(e.key)) { e.preventDefault(); endMazeQTE(e.key === correctKey); } }; document.addEventListener('keydown', keydownHandler); if(isTouchDevice) { mobileControlsContainer.innerHTML = `<button class="mobile-btn" data-key="ArrowUp">â¬†ï¸</button><button class="mobile-btn" data-key="ArrowLeft">â¬…ï¸</button><button class="mobile-btn" data-key="ArrowDown">â¬‡ï¸</button><button class="mobile-btn" data-key="ArrowRight">â¡ï¸</button>`; mobileControlsContainer.classList.add('visible'); mobileControlsContainer.onclick = (e) => { if(e.target.dataset.key) { endMazeQTE(e.target.dataset.key === correctKey); } } } }
    function endMazeQTE(success) { minigameArea.style.display = 'block'; const flash = document.createElement('div'); flash.className = 'screen-flash'; flash.style.backgroundColor = success ? 'rgba(144, 238, 144, 0.5)' : 'rgba(255, 99, 71, 0.5)'; document.body.appendChild(flash); setTimeout(() => flash.remove(), 400); if (success) { showEndScreen("é¸å°äº†è·¯ï¼æš«æ™‚å®‰å…¨äº†ã€‚", "åœ¨è¿·å®®ä¸­é¸å°äº†æ–¹å‘ï¼Œæœ‰é©šç„¡éšªã€‚", true); } else { const moneyLost = calculateEarnings(50, true); money = Math.max(0, money - moneyLost); showEndScreen(`æ˜¯æ­»è·¯ï¼ä½ è¿·å¤±åœ¨å…¶ä¸­...æå¤±äº† ${moneyLost} ğŸ’°ã€‚`, `åœ¨è¿·å®®ä¸­èµ°éŒ¯äº†è·¯ï¼Œæå¤± ${moneyLost} ğŸ’°ã€‚`, false); } }
    function startDodgeShadows() { let duration = 10; showMinigame(); minigameTitle.textContent = "ğŸ‘» èº²é¿é™°å½± ğŸ‘»"; minigameInstruction.textContent = "ç§»å‹•æ»‘é¼ æˆ–æ‰‹æŒ‡ï¼Œæ§åˆ¶å…‰çƒèº²é¿æ‰è½çš„é™°å½±ï¼"; minigameInfoBar.innerHTML = `<span>æ’ä½: <span id="timer">${duration}</span>s</span>`; const timerEl = document.getElementById('timer'); const player = document.createElement('div'); player.id = 'player-avatar'; minigameArea.appendChild(player); const movePlayer = (clientX) => { const areaRect = minigameArea.getBoundingClientRect(); player.style.left = `${clientX - areaRect.left - player.offsetWidth / 2}px`; }; mousemoveHandler = (e) => movePlayer(e.clientX); touchMoveHandler = (e) => { e.preventDefault(); if (e.touches[0]) movePlayer(e.touches[0].clientX); }; minigameArea.addEventListener('mousemove', mousemoveHandler); minigameArea.addEventListener('touchmove', touchMoveHandler, { passive: false }); const shadowSpawner = setInterval(() => { if (!minigameActive) { clearInterval(shadowSpawner); return; } const shadow = document.createElement('div'); shadow.className = 'shadow-obstacle'; shadow.style.left = `${Math.random() * 90}%`; shadow.style.animationDuration = `${1.2 + Math.random()}s`; minigameArea.appendChild(shadow); const checkCollision = setInterval(() => { if (!minigameActive) { clearInterval(checkCollision); return; } const playerRect = player.getBoundingClientRect(); const shadowRect = shadow.getBoundingClientRect(); if (playerRect.left < shadowRect.right && playerRect.right > shadowRect.left && playerRect.top < shadowRect.bottom && playerRect.bottom > shadowRect.top) { clearInterval(checkCollision); clearInterval(shadowSpawner); endDodgeShadows(false); } }, 50); setTimeout(() => { clearInterval(checkCollision); shadow.remove(); }, 2200); }, 400); gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); clearInterval(shadowSpawner); endDodgeShadows(true); } }, 1000); }
    function endDodgeShadows(survived) { if (!minigameActive) return; if (survived) { showEndScreen("ä½ æˆåŠŸæ´»äº†ä¸‹ä¾†ï¼å¤©äº®äº†ã€‚", "ä½ åœ¨é™°å½±ä¸­å­˜æ´»äº†ä¸‹ä¾†ï¼Œæ¯«é«®ç„¡å‚·ã€‚", true); } else { const moneyLost = calculateEarnings(60, true); money = Math.max(0, money - moneyLost); showEndScreen(`è¢«é™°å½±æŠ“ä½äº†ï¼æå¤±äº† ${moneyLost} ğŸ’°ã€‚`, `ä½ è¢«é™°å½±åå™¬ï¼Œæå¤±äº† ${moneyLost} ğŸ’°ã€‚`, false); } }
    function startDreamWeaving() { let score = 0; let duration = 15 + (incenseLevel - 1); let currentLevel = 0; let requiredClicks = 0; showMinigame(); minigameTitle.textContent = "âœ¨ å¤¢å¢ƒç·¨ç¹” âœ¨"; minigameInstruction.textContent = "ä¾åºé»æ“Šæ•¸å­—ï¼Œå°‡å¤¢å¢ƒç¢ç‰‡é€£æ¥èµ·ä¾†ã€‚"; minigameInfoBar.innerHTML = `<span>æ™‚é–“: <span id="timer">${duration}</span>s</span> <span>åˆ†æ•¸: <span id="score">0</span></span>`; const timerEl = document.getElementById('timer'); const scoreEl = document.getElementById('score'); function nextLevel() { minigameArea.innerHTML = ''; currentLevel++; requiredClicks = 0; let fragmentPositions = []; const numFragments = 2 + currentLevel; const minDistance = 15; for (let i = 1; i <= numFragments; i++) { let pos; let validPosition = false; let attempts = 0; while (!validPosition && attempts < 100) { pos = { top: 10 + Math.random() * 75, left: 10 + Math.random() * 80 }; validPosition = true; for (const existingPos of fragmentPositions) { const dist = Math.sqrt(Math.pow(pos.top - existingPos.top, 2) + Math.pow(pos.left - existingPos.left, 2)); if (dist < minDistance) { validPosition = false; break; } } attempts++; } fragmentPositions.push(pos); const fragment = document.createElement('div'); fragment.className = 'dream-fragment'; fragment.textContent = i; fragment.style.top = `${pos.top}%`; fragment.style.left = `${pos.left}%`; fragment.onclick = () => onFragmentClick(fragment, i); minigameArea.appendChild(fragment); } } function onFragmentClick(element, num) { if (!minigameActive || num !== requiredClicks + 1) return; requiredClicks++; element.classList.add('clicked'); element.onclick = null; if (requiredClicks === (2 + currentLevel)) { score++; scoreEl.textContent = score; nextLevel(); } } gameInterval = setInterval(() => { duration--; timerEl.textContent = duration; if (duration <= 0) { clearInterval(gameInterval); endDreamWeaving(score); } }, 1000); nextLevel(); }
    function endDreamWeaving(finalScore) { const earnings = calculateEarnings(finalScore * finalScore * pillowLevel * 2); money += earnings; showEndScreen(`ç·¨ç¹”å®Œæˆï¼ä½ å®Œæˆäº† ${finalScore} å€‹æ˜Ÿåº§ã€‚ç²å¾— ${earnings} ğŸ’°ï¼`, `ä½ åœ¨å¤¢ä¸­ç·¨ç¹”äº† ${finalScore} å€‹æ˜Ÿåº§ï¼Œç²å¾— ${earnings} ğŸ’°ã€‚`, true); }
    function startSleepParalysis() { let progress = 0; let duration = 10; let isHolding = false; showMinigame(); minigameTitle.textContent = "ğŸ‘» é¬¼å£“åºŠ ğŸ‘»"; minigameInstruction.textContent = "æŒ‰ä½ [ç©ºç™½éµ] æˆ–ä¸‹æ–¹æŒ‰éˆ•ä¾†ç©è“„æ„å¿—åŠ›ï¼Œä½†è¦é¿é–‹ææ‡¼çš„è„ˆè¡ï¼"; minigameInfoBar.innerHTML = `<span>å‰©é¤˜æ™‚é–“: <span id="timer">${duration}</span>s</span>`; minigameArea.innerHTML = '<div id="paralysis-bar-container"><div id="paralysis-bar"></div></div><div id="paralysis-pulse"></div>'; const timerEl = document.getElementById('timer'); const bar = document.getElementById('paralysis-bar'); const pulse = document.getElementById('paralysis-pulse'); let isPulsing = false; const pulseCheck = setInterval(() => { isPulsing = parseFloat(getComputedStyle(pulse).opacity) > 0.5; }, 50); keydownHandler = e => { if (e.code === 'Space') { e.preventDefault(); if(!isHolding) isHolding = true; } }; keyupHandler = e => { if (e.code === 'Space') { e.preventDefault(); isHolding = false; } }; document.addEventListener('keydown', keydownHandler); document.addEventListener('keyup', keyupHandler); if(isTouchDevice) { mobileControlsContainer.innerHTML = `<button id="mobile-hold-button">æŒ‰ä½</button>`; mobileControlsContainer.classList.add('visible'); const holdButton = document.getElementById('mobile-hold-button'); touchStartHandler = e => { e.preventDefault(); isHolding = true; }; touchEndHandler = e => { e.preventDefault(); isHolding = false; }; holdButton.addEventListener('touchstart', touchStartHandler, { passive: false }); holdButton.addEventListener('touchend', touchEndHandler, { passive: false }); } gameInterval = setInterval(() => { if (isHolding) { if (isPulsing) { progress -= 10; } else { progress += 2.5 + (incenseLevel - 1) * 0.2; } } else { progress -= 0.5; } progress = Math.max(0, Math.min(100, progress)); bar.style.width = `${progress}%`; if (progress >= 100) { clearInterval(gameInterval); clearInterval(pulseCheck); endSleepParalysis(true); return; } duration -= 0.05; timerEl.textContent = Math.ceil(duration); if (duration <= 0) { clearInterval(gameInterval); clearInterval(pulseCheck); endSleepParalysis(false); } }, 50); }
    function endSleepParalysis(success) { if (success) { showEndScreen("ä½ æˆ°å‹äº†ææ‡¼ï¼ŒæˆåŠŸé†’ä¾†ï¼", "ä½ å¾é¬¼å£“åºŠä¸­æˆåŠŸæ™è„«ï¼Œæœ‰é©šç„¡éšªã€‚", true); } else { const moneyLost = calculateEarnings(70, true); money = Math.max(0, money - moneyLost); showEndScreen(`æ„å¿—åŠ›è€—ç›¡...ä½ è¢«å›°åœ¨äº†ææ‡¼ä¸­ã€‚æå¤± ${moneyLost} ğŸ’°ã€‚`, `è¢«é¬¼å£“åºŠæ“Šæ•—ï¼Œæå¤±äº† ${moneyLost} ğŸ’°ã€‚`, false); } }
    
    // --- 7. éŠæˆ²åˆå§‹åŒ– ---
    document.addEventListener('DOMContentLoaded', () => {
        gameContainer = document.getElementById('game-container'); dayCountEl = document.getElementById('day-count'); moneyEl = document.getElementById('money'); goodDreamChanceEl = document.getElementById('good-dream-chance'); gameLogEl = document.getElementById('game-log'); sleepButton = document.getElementById('sleep-button'); bedLevelEl = document.getElementById('bed-level'); pillowLevelEl = document.getElementById('pillow-level'); dreamCatcherLevelEl = document.getElementById('dreamcatcher-level'); incenseLevelEl = document.getElementById('incense-level'); bedUpgradeCostEl = document.getElementById('bed-upgrade-cost'); pillowUpgradeCostEl = document.getElementById('pillow-upgrade-cost'); dreamCatcherUpgradeCostEl = document.getElementById('dreamcatcher-upgrade-cost'); incenseUpgradeCostEl = document.getElementById('incense-upgrade-cost'); upgradeBedButton = document.getElementById('upgrade-bed-button'); upgradePillowButton = document.getElementById('upgrade-pillow-button'); upgradeDreamCatcherButton = document.getElementById('upgrade-dreamcatcher-button'); upgradeIncenseButton = document.getElementById('upgrade-incense-button'); minigameModal = document.getElementById('minigame-modal'); minigameTitle = minigameModal.querySelector('h3'); minigameInstruction = minigameModal.querySelector('p'); minigameInfoBar = minigameModal.querySelector('#minigame-info-bar'); minigameArea = minigameModal.querySelector('#minigame-area'); minigameResultEl = minigameModal.querySelector('#minigame-result'); mobileControlsContainer = minigameModal.querySelector('#mobile-controls-container'); eventModal = document.getElementById('event-modal'); eventResultEl = eventModal.querySelector('#event-result'); cardContainer = document.getElementById('card-container'); goodDreamItemCostEl = document.getElementById('good-dream-item-cost'); badDreamItemCostEl = document.getElementById('bad-dream-item-cost'); buyGoodDreamItemButton = document.getElementById('buy-good-dream-item-button'); buyBadDreamItemButton = document.getElementById('buy-bad-dream-item-button'); merchantModal = document.getElementById('merchant-modal'); merchantTimerEl = document.getElementById('merchant-timer'); merchantItemsEl = merchantModal.querySelector('#merchant-items'); potionEffectStatusEl = document.getElementById('potion-effect-status'); settingsButton = document.getElementById('settings-button'); settingsModal = document.getElementById('settings-modal'); deleteSaveButton = document.getElementById('delete-save-button'); settingsCloseButton = document.getElementById('settings-close-button'); storyModal = document.getElementById('story-modal'); storyModalTitle = document.getElementById('story-modal-title'); storyModalText = document.getElementById('story-modal-text'); storyModalCloseButton = document.getElementById('story-modal-close-button'); endingModal = document.getElementById('ending-modal'); endingText = document.getElementById('ending-text'); endingResetButton = document.getElementById('ending-reset-button'); endingContinueButton = document.getElementById('ending-continue-button'); backpackButton = document.getElementById('backpack-button'); backpackModal = document.getElementById('backpack-modal'); backpackItemsEl = document.getElementById('backpack-items'); backpackCloseButton = document.getElementById('backpack-close-button');
        
        sleepButton.addEventListener('click', goToSleep); upgradeBedButton.addEventListener('click', upgradeBed); upgradePillowButton.addEventListener('click', upgradePillow); upgradeDreamCatcherButton.addEventListener('click', upgradeDreamCatcher); upgradeIncenseButton.addEventListener('click', upgradeIncense);
        buyGoodDreamItemButton.addEventListener('click', () => buyItem('luckyClover', goodDreamItemCost));
        buyBadDreamItemButton.addEventListener('click', () => buyItem('cursedDoll', badDreamItemCost));
        settingsButton.addEventListener('click', () => { settingsModalActive = true; settingsModal.classList.remove('hidden'); updateStatsUI(); });
        settingsCloseButton.addEventListener('click', () => { settingsModalActive = false; settingsModal.classList.add('hidden'); updateStatsUI(); });
        deleteSaveButton.addEventListener('click', deleteSaveAndReset);
        storyModalCloseButton.addEventListener('click', () => { storyModalActive = false; storyModal.classList.add('hidden'); gameContainer.classList.remove('frozen'); saveGameAndUpdateUI(); });
        endingResetButton.addEventListener('click', deleteSaveAndReset);
        endingContinueButton.addEventListener('click', () => { endingActive = false; endingModal.classList.add('hidden'); gameContainer.classList.remove('frozen'); saveGameAndUpdateUI(); });
        backpackButton.addEventListener('click', openBackpack);
        backpackCloseButton.addEventListener('click', closeBackpack);
        backpackItemsEl.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.itemId) { useItem(e.target.dataset.itemId); } });

        loadGame();
        updateStatsUI(); 
        mainEventInterval = setInterval(triggerRandomEvent, 60000);
    });
    </script>
</body>
</html>